深入应用C++11代码优化与工程级应用 PDF下载 祁宇 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150069
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150069
<p>书名:深入应用C++11代码优化与工程级应用</p><p>作者:祁宇</p><p>页数:413</p><p>定价:¥79.0</p><p>出版社:机械工业出版社</p><p>出版日期:2015-05-01</p><p>ISBN:9787111500698</p><p><h2>本书特色</h2></p>[<p>
本书专注于c++11的深入应用，主要分为两个部分。前半部分介绍c++11的新特性，不追求大而全，将重点介绍一些常用的特性，有侧重地从另外一个角度将这些特性分门别类，即通过介绍这些新特性如何去改进我们现有程序的角度介绍。这种方式一来可以让读者学习这些新特性的用法；二来还可以让读者知道这些特性是如何改进现有程序的，从而能更深刻地领悟c+11的新特性。本书的后半部分的工程级应用就是实战，通过丰富的开发案例来介绍如何用c++11去开发项目，因为只有在实战中才能学到真东西。后半部分实战案例涉及面比较广，是笔者近年来使用c++11的经验与心得。这些案例是针对在实际开发过程中遇到的问题来选取的，它们的价值不仅仅是作为应用c++11实践知道，还可以直接在实际开发中应用，相信这些实战案例一定能给读者带来更深入的思考。
                                        </p>]<p><h2>目录</h2></p>
    目  录?contents前言**篇 c++11改进我们的程序第1章 使用c++11让程序更简洁、更现代  21.1 类型推导  21.1.1 auto类型推导  21.1.2 decltype关键字  91.1.3 返回类型后置语法——auto和decltype的结合使用  141.2 模板的细节改进  161.2.1 模板的右尖括号  161.2.2 模板的别名  181.2.3 函数模板的默认模板参数  201.3 列表初始化  221.3.1 统一的初始化  231.3.2 列表初始化的使用细节  251.3.3 初始化列表  291.3.4 防止类型收窄  321.4 基于范围的for循环  341.4.1 for循环的新用法  341.4.2 基于范围的 for循环的使用细节  361.4.3 让基于范围的 for循环支持自定义类型  401.5 std::function和bind绑定器  471.5.1 可调用对象  471.5.2 可调用对象包装器——std::function  491.5.3 std::bind绑定器  521.6 lambda表达式  561.6.1 lambda表达式的概念和基本用法  561.6.2 声明式的编程风格，简洁的代码  591.6.3 在需要的时间和地点实现闭包，使程序更灵活  601.7 tupe元组  611.8 总结  63第2章 使用c++11改进程序性能  642.1 右值引用  642.1.1 &&的特性  652.1.2 右值引用优化性能，避免深拷贝  712.2 move语义  772.3 forward和完美转发  782.4 emplace_back减少内存拷贝和移动  812.5 unordered container无序容器  832.6 总结  85第3章 使用c++11消除重复，提高代码质量  863.1 type_traits——类型萃取  863.1.1 基本的type_traits  873.1.2 根据条件选择的traits  963.1.3 获取可调用对象返回类型的traits  963.1.4 根据条件禁用或启用某种或某些类型traits  993.2 可变参数模板  1033.2.1 可变参数模板函数  1033.2.2 可变参数模板类  1073.2.3 可变参数模板消除重复代码  1113.3 可变参数模版和type_taits的综合应用  1143.3.1 optional的实现  1143.3.2 惰性求值类lazy的实现  1183.3.3 dll帮助类  1223.3.4 lambda链式调用  1263.3.5 any类的实现  1283.3.6 function_traits  1313.3.7 variant的实现  1343.3.8 scopeguard  1403.3.9 tuple_helper  1413.4 总结  153第4章 使用c++11解决内存泄露的问题  1554.1 shared_ptr共享的智能指针  1554.1.1 shared_ptr的基本用法  1564.1.2 使用shared_ptr需要注意的问题  1574.2 unique_ptr独占的智能指针  1594.3 weak_ptr弱引用的智能指针  1614.3.1 weak_ptr基本用法  1614.3.2 weak_ptr返回this指针  1624.3.3 weak_ptr解决循环引用问题  1634.4 通过智能指针管理第三方库分配的内存  1644.5 总结  166第5章 使用c++11让多线程开发变得简单  1675.1 线程  1675.1.1 线程的创建  1675.1.2 线程的基本用法  1705.2 互斥量  1715.2.1 独占互斥量std::mutex  1715.2.2 递归互斥量std::recursive_mutex  1725.2.3 带超时的互斥量std::timed_mutex和std::recursive_timed_mutex  1745.3 条件变量  1755.4 原子变量  1795.5 call_once/once_flag的使用  1805.6 异步操作  1815.6.1 获取线程函数返回值的类std::future  1815.6.2 协助线程赋值的类 std::promise  1825.6.3 可调用对象的包装类std::package_task  1825.6.4 std::promise、std::packaged_task和std::future三者之间的关系  1835.7 线程异步操作函数async  1845.8 总结  185第6章 使用c++11中便利的工具  1866.1 处理日期和时间的chrono库  1866.1.1 记录时长的duration  1866.1.2 表示时间点的time point  1886.1.3 获取系统时钟的clocks  1906.1.4 计时器timer  1916.2 数值类型和字符串的相互转换  1936.3 宽窄字符转换  1956.4 总结  196第7章 c++11的其他特性  1977.1 委托构造函数和继承构造函数  1977.1.1 委托构造函数  1977.1.2 继承构造函数  1997.2 原始的字面量  2017.3 f?inal和override关键字  2037.4 内存对齐  2047.4.1 内存对齐介绍  2047.4.2 堆内存的内存对齐  2077.4.3 利用alignas指定内存对齐大小  2077.4.4 利用alignof和std::alignment_of获取内存对齐大小  2087.4.5 内存对齐的类型std::aligned_storage  2097.4.6 std::max_align_t和std::align操作符  2117.5 c++11新增的便利算法  2117.6 总结  216第二篇 c++11工程级应用第8章 使用c++11改进我们的模式  2188.1 改进单例模式  2188.2 改进观察者模式  2238.3 改进访问者模式  2278.4 改进命令模式  2328.5 改进对象池模式  2368.6 总结  240第9章 使用c++11开发一个半同步半异步线程池  2419.1 半同步半异步线程池介绍  2419.2 线程池实现的关键技术分析  2429.3 同步队列  2439.4 线程池  2479.5 应用实例  2509.6 总结  251第10章 使用c++11开发一个轻量级的aop库  25210.1 aop介绍  25210.2 aop的简单实现  25310.3 轻量级的aop框架的实现  25510.4 总结  260第11章 使用c++11开发一个轻量级的ioc容器  26111.1 ioc容器是什么  26111.2 ioc创建对象  26511.3 类型擦除的常用方法  26711.4 通过any和闭包来擦除类型  26911.5 创建依赖的对象  27311.6 完整的ioc容器  27511.7 总结  283第12章 使用c++11开发一个对象的消息总线库  28412.1 消息总线介绍  28412.2 消息总线关键技术  28412.2.1 通用的消息定义  28512.2.2 消息的注册  28512.2.3 消息分发  28912.2.4 消息总线的设计思想  28912.3 完整的消息总线  29212.4 应用实例  29712.5 总结  301第13章 使用c++11封装sqlite库  30213.1 sqlite基本用法介绍  30313.1.1 打开和关闭数据库的函数  30413.1.2 执行sql语句的函数  30513.2 rapidjson基本用法介绍  31013.2.1 解析json字符串  31013.2.2 创建json对象  31113.2.3 对rapidjson的一点扩展  31513.3 封装sqlite的smartdb  31613.3.1 打开和关闭数据库的接口  31713.3.2 excecute接口  31913.3.3 executescalar接口  32313.3.4 事务接口  32513.3.5 excecutetuple接口  32513.3.6 json接口  32713.3.7 查询接口  32913.4 应用实例  33213.5 总结  335第14章 使用c++11开发一个linq to objects库  33614.1 linq介绍  33614.1.1 linq语义  33614.1.2 linq标准操作符（c#）  33714.2 c++中的linq  33914.3 linq实现的关键技术  34014.3.1 容器和数组的泛化  34114.3.2 支持所有的可调用对象  34414.3.3 链式调用  34514.4 linq to objects的具体实现  34714.4.1 一些典型linq操作符的实现  34714.4.2 完整的linq to objects的实现  34914.5 linq to objects的应用实例  35814.6 总结  360第15章 使用c++11开发一个轻量级的并行task库  36115.1 tbb的基本用法  36215.1.1 tbb概述  36215.1.2 tbb并行算法  36215.1.3 tbb的任务组  36515.2 ppl的基本用法  36515.2.1 ppl任务的链式连续执行  36515.2.2 ppl的任务组  36615.3 tbb和ppl的选择  36715.4 轻量级的并行库taskcpp的需求  36715.5 taskcpp的任务  36815.5.1 task的实现  36815.5.2 task的延续  36915.6 taskcpp任务的组合  37215.6.1 taskgroup  37215.6.2 whenall  37615.6.3 whenany  37815.7 taskcpp并行算法  38115.7.1 parallelforeach：并行对区间元素执行某种操作  38115.7.2 parallelinvoke：并行调用  38215.7.3 parallelreduce：并行汇聚  38315.8 总结  386第16章  使用c++11开发一个简单的通信程序  38716.1 反应器和主动器模式介绍  38716.2 asio中的proactor  39116.3 asio的基本用法  39416.3.1 异步接口  39516.3.2 异步发送  39716.4 c++11结合asio实现一个简单的服务端程序  39916.5 c++11结合asio实现一个简单的客户端程序  40516.6 tcp粘包问题的解决  40816.7 总结  413参考文献  414
