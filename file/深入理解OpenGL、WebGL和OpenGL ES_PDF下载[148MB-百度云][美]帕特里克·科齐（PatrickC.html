深入理解OpenGL、WebGL和OpenGL ES PDF下载 [美]帕特里克·科齐（PatrickC 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730255225
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730255225
<p>书名:深入理解OpenGL、WebGL和OpenGL ES</p><p>作者:[美]帕特里克·科齐（Patrick C</p><p>页数:0</p><p>定价:¥199.0</p><p>出版社:清华大学出版社</p><p>出版日期:2020-05-01</p><p>ISBN:9787302552253</p><p><h2>本书特色</h2></p>[<p>
本书详细阐述了与OpenGL相关的基本解决方案，主要包括渲染技术、混合管线、性能、传输、调试和性能分析、软件设计等内容。此外，本书还提供了相应的示例，以帮助读者进一步理解相关方案的实现过程。 本书适合作为高等院校计算机及相关专业的教材和教学参考书，也可作为相关开发人员的自学教材和参考手册。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书详细阐述了与OpenGL相关的基本解决方案，主要包括渲染技术、混合管线、性能、传输、调试和性能分析、软件设计等内容。此外，本书还提供了相应的示例，以帮助读者进一步理解相关方案的实现过程。
本书适合作为高等院校计算机及相关专业的教材和教学参考书，也可作为相关开发人员的自学教材和参考手册。</p>]<p><h2>目录</h2></p>
    第1篇  发现
第1章  基于着色器的OpenGL计算机图形学课程
1.1  简介
1.2  基础课程
1.3  简单的OpenGL示例
1.4  从可编程管线开始
1.5  新的简单示例
1.5.1  OpenGL  ES和WebGL
1.5.2  **项作业
1.6  课程的其余部分
1.6.1  几何
1.6.2  变换和视图
1.6.3  照明和着色
1.6.4  纹理和离散处理
1.6.5  高级主题
1.6.6  问题
1.7  小结
致谢
参考文献
 
第2章  过渡到新OpenGL版本
2.1  概述
2.2  命名着色器变量：简介
2.3  命名着色器变量：详细信息
2.4  索引顶点缓冲区对象C 类
2.4.1  使用注意事项
2.4.2  示例代码
2.4.3  实现说明
2.5  GLSLProgram  C 类
2.5.1  使用注意事项
2.5.2  示例代码
2.5.3  实现说明
2.6  小结
参考文献
 
第3章  适用于OpenGL开发人员的WebGL
3.1  简介
3.2  WebGL的优势
3.2.1  零要求
3.2.2  跨平台
3.2.3  跨设备
3.2.4  易开发
3.2.5  强大的工具支持
3.2.6  性能
3.3  安全性
3.3.1  跨源请求
3.3.2  上下文丢失
3.4  部署着色器
3.5  关于JavaScript语言
3.5.1  JavaScript类型
3.5.2  动态类型
3.5.3  函数范围
3.5.4  函数编程
3.5.5  原型对象
3.5.6  this关键字
3.5.7  代码组织
3.5.8  常见错误
3.6  资源
参考文献
 
第4章  将移动应用程序移植到WebGL
4.1  简介
4.2  跨平台的OpenGL
4.3  入门
4.3.1  初始化OpenGL  ES上下文
4.3.2  加载着色器
4.3.3  绘制顶点
4.4  加载纹理
4.4.1  分配纹理
4.4.2  处理异步加载
4.5  相机和矩阵
4.5.1  对比float和Float32Array
4.5.2  将矩阵传递给着色器
4.6  控制
4.6.1  触摸事件
4.6.2  在相机和碰撞中使用触摸事件
4.7  其他考虑因素
4.7.1  动画
4.7.2  继承
4.8  维护
4.8.1  调试
4.8.2  性能分析
4.8.3  性能和采用
4.9  小结
参考文献
 
第5章  GLSL着色器接口
5.1  简介
5.2  变量和块
5.2.1  用户定义的变量和块
5.2.2  内置变量和块
5.3  位置
5.3.1  定义
5.3.2  计算位置
5.3.3  位置限制
5.4  匹配接口
5.4.1  部分和完全匹配
5.4.2  类型匹配
5.4.3  按名称和位置匹配
5.4.4  按块匹配
5.4.5  按结构匹配
5.4.6  链接和单独的程序
5.5  使用语义
5.5.1  编译器生成的变化的位置和显式位置
5.5.2  顶点数组属性和顶点着色器输入
5.5.3  片段着色器输出和帧缓冲区颜色附加数据
5.5.4  变化的输出和变化的输入
5.5.5  统一格式缓冲区和统一格式块
5.6  仅适用于调试的应用程序端验证
5.6.1  顶点输入验证
5.6.2  变化的接口验证
5.6.3  片段输出验证
5.6.4  变量验证
5.6.5  统一格式块验证
5.7  小结
致谢
参考文献
 
第6章  曲面细分着色器简介
6.1  简介
6.1.1  细分表面
6.1.2  平滑多边形数据
6.1.3  GPU计算
6.1.4  曲线、头发和草地
6.1.5  其他用途
6.2  新的着色管道
6.2.1  图块的生命
6.2.2  线程模型
6.2.3  输入和输出
6.2.4  曲面细分控制着色器
6.2.5  曲面细分评估着色器
6.2.6  使用quads生成图元
6.2.7  使用triangles生成图元
6.3  对茶壶进行曲面细分
6.4  等值线和螺旋
6.5  结合其他OpenGL功能
参考文献
 
第7章  GLSL中的程序纹理
7.1  简介
7.2  简单函数
7.3  抗锯齿
7.4  Perlin噪声
7.5  Worley噪声
7.6  动画
7.7  纹理图像
7.8  性能
7.9  小结
参考文献
 
第8章  基于OpenGL和OpenGL  ES的OpenGL  SC仿真
8.1  简介
8.2  OpenGL  SC实现
8.3  设计和实现
8.3.1  总体管线
8.3.2  纹理管线
8.4  结果
8.5  小结
参考文献
 
第9章  混合图形和使用多个GPU进行计算
9.1  简介
9.2  API级别的图形和计算互操作性
9.2.1  互操作性准备
9.2.2  OpenGL对象交互
9.3  系统级的图形和计算互操作性
9.4  小结
参考文献
 
第2篇  渲染技术
第10章  GPU曲面细分：地形LOD讨论
10.1  简介
10.2  使用OpenGL  GPU曲面细分渲染地形
10.3  动态LOD的简单方法
10.4  粗糙度和细节
10.5  渲染测试
10.5.1  测试设置
10.5.2  评估LOD解决方案的质量
10.5.3  性能
10.6  小结
参考文献
 
第11章  使用基于着色器的抗锯齿体积线
11.1  简介
11.2  后处理抗锯齿
11.3  抗锯齿体积线
11.3.1  使用顶点着色器进行几何体挤出
11.3.2  使用几何着色器进行几何体挤出
11.4  性能
11.5  小结
参考文献
 
第12章  通过距离场渲染2D形状
12.1  简介
12.2  方法概述
12.3  更好的距离场算法
12.4  距离纹理
12.5  硬件加速距离变换
12.6  片段渲染
12.7  特效
12.8  性能
12.9  缺点
12.10  小结
参考文献
 
第13章  WebGL中的高效文本渲染
13.1  简介
13.2  基于画布的字体渲染
13.2.1  HTML5  Canvas
13.2.2  概念
13.2.3  实现
13.3  位图字体渲染
13.3.1  概念
13.3.2  创建位图字体
13.3.3  实现
13.4  对比
13.4.1  性能
13.4.2  内存使用情况
13.4.3  开发难度
13.5  小结
参考文献
 
第14章  分层纹理渲染管线
14.1  简介
14.1.1  术语
14.1.2  在Blender软件中的纹理
14.2  分层管线
14.2.1  关于G缓冲区创建
14.2.2  层解决方案
14.2.3  统一的视差偏移
14.2.4  照明
14.3  实现和结果
14.3.1  实现
14.3.2  结果
14.4  小结
参考文献
 
第15章  景深与模糊渲染
15.1  简介
15.2  景深现象
15.3  相关工作
15.4  算法
15.4.1  概述
15.4.2  模糊圈的计算
15.4.3  散景检测
15.4.4  基于模糊的景深
15.4.5  散景渲染
15.5  结果
15.6  讨论
15.7  小结
参考文献
 
第16章  阴影代理
16.1  简介
16.2  对阴影代理的剖析
16.3  设置管线
16.4  启用ShadowProxy的片段着色器
16.5  调整阴影体积
16.6  性能
16.7  小结
参考文献
 
第3篇  混合管线
第17章  使用变换反馈的基于物理学的实时变形
17.1  简介
17.2  硬件支持和变换反馈的演变
17.3  变换反馈的机制
17.4  数学模型
17.5  实现
17.5.1  使用Verlet积分顶点着色器
17.5.2  注册属性以变换反馈
17.5.3  数组缓冲区和缓冲区对象设置
17.5.4  数据的动态修改
17.6  实验结果和比较
17.7  小结
参考文献
 
第18章  GPU上的分层深度剔除和包围盒管理
18.1  简介
18.2  管线
18.2.1  早期深度通道
18.2.2  深度LOD构造
18.2.3  包围盒更新
18.2.4  分层深度剔除
18.2.5  包围盒调试绘图
18.3  操作顺序
18.4  实验结果
18.5  小结
参考文献
 
第19章  使用分层渲染的大量阴影
19.1  简介
19.2  在OpenGL中的传统阴影贴图渲染技术
19.3  阴影贴图生成算法
19.4  性能
19.4.1  使用复杂顶点着色器的性能
19.4.2  视锥体剔除优化
19.4.3  背面剔除优化
19.5  高级技术
19.6  局限性
19.7  小结
参考文献
 
第20章  高效的分层片段缓冲区技术
20.1  简介
20.2  相关工作
20.3  链表LFB
20.4  线性化LFB
20.5  性能结果
20.6  小结
参考文献
 
第21章  可编程顶点拉动
21.1  简介
21.2  实现
21.3  性能
21.4  应用
21.5  局限性
21.6  小结
参考文献
 
第22章  使用GPU硬件光栅化器进行基于八叉树的稀疏体素化
22.1  简介
22.2  以前的工作成果
22.3  关于GLSL中的无限制内存访问
22.4  简单的体素化管线
22.4.1  保守光栅化
22.4.2  组合体素片段
22.4.3  结果
22.5  稀疏体素化为八叉树
22.5.1  八叉树结构
22.5.2  稀疏体素化概述
22.5.3  使用原子计数器进行体素-片段列表构建
22.5.4  节点细分
22.5.5  写入和Mipmap值
22.5.6  使用间接绘图实现无同步内核启动
22.5.7  结果与讨论
22.6  小结
致谢
参考文献
 
第4篇  性  能
第23章  基于图块架构的性能调优
23.1  简介
23.2  背景
23.3  清除和丢弃帧缓冲区
23.4  增量帧更新
23.5  冲洗
23.6  延迟
23.7  隐藏表面消除
23.8  混合
23.9  多重采样
23.10  性能分析
23.11  小结
参考文献
 
第24章  探索移动与桌面OpenGL性能
24.1  简介
24.2  重要的差异和约束
24.2.1  尺寸差异
24.2.2  渲染架构差异
24.2.3  内存架构差异
24.3  减少内存带宽
24.3.1  相对显示尺寸
24.3.2  帧缓冲区带宽
24.3.3  抗锯齿
24.3.4  纹理带宽
24.3.5  纹理过滤和带宽
24.4  减少片段工作负载
24.4.1  过度绘制和混合
24.4.2  全屏效果
24.4.3  屏幕外通道
24.4.4  修剪片段工作
24.5  顶点着色
24.6  小结
参考文献
 
第25章  通过减少对驱动程序的调用来提高性能
25.1  简介
25.2  高效的OpenGL状态使用
25.2.1  检测冗余状态修改
25.2.2  有效状态修改的一般方法
25.3  批处理和实例化
25.3.1  批处理
25.3.2  关于OpenGL实例化
25.4  小结
致谢
参考文献
 
第26章  索引多个顶点数组
26.1  简介
26.2  问题
26.3  算法
26.4  顶点比较方法
26.4.1  关于If/Then/Else版本
26.4.2  关于memcmp（）版本
26.4.3  哈希函数
26.5  性能
26.6  小结
参考文献
 
第27章  NVIDIA  Quadro上的多GPU渲染
27.1  简介
27.2  以前的扩展方法
27.3  指定特定GPU进行渲染
27.4  优化GPU之间的数据传输
27.5  多GPU的应用结构
27.6  并行渲染方法
27.6.1  先排序图像分解
27.6.2  后排序数据分解
27.6.3  立体渲染
27.6.4  服务器端渲染
27.7  小结
参考文献
 
第5篇  传输
第28章  异步缓冲区传输
28.1  简介
28.2  缓冲区对象
28.2.1  内存传输
28.2.2  使用提示
28.2.3  隐式同步
28.2.4  同步原语
28.3  上传
28.3.1  轮询（多个缓冲区对象）
28.3.2  缓冲区重新指定（孤立）
28.3.3  非同步缓冲区
28.3.4  关于AMD_pinned_memory扩展
28.4  下载
28.5  复制
28.6  多线程和共享上下文
28.6.1  多线程OpenGL简介
28.6.2  同步问题
28.6.3  内部同步导致的性能损失
28.6.4  关于共享上下文的总结
28.7  使用方案
28.7.1  方法1：单线程
28.7.2  方法2：两个线程和一个OpenGL上下文
28.7.3  方法3：两个线程和两个OpenGL共享上下文
28.7.4  性能比较
28.8  小结
参考文献
 
第29章  费米异步纹理传输
29.1  简介
29.2  关于OpenGL命令缓冲区执行
29.3  当前纹理传输方法
29.3.1  同步纹理传输
29.3.2  CPU异步纹理传输
29.4  GPU异步纹理传输
29.5  实现细节
29.5.1  多个OpenGL上下文
29.5.2  同步
29.5.3  复制引擎注意事项
29.6  结果与分析
29.7  小结
参考文献
 
第30章  WebGL模型：端到端
30.1  简介
30.2  关于3D模型的生命周期
30.2.1  第1阶段：管线
30.2.2  第2阶段：服务
30.2.3  第3阶段：加载
30.2.4  第4阶段：渲染
30.3  整体一致性
30.3.1  Delta编码
30.3.2  Delta编码分析
30.3.3  ZigZag编码
30.3.4  Delta ZigZag编码分析
30.3.5  压缩管线
30.4  主要改进
30.4.1  交错和转置的对比
30.4.2  高水位线预测
30.4.3  性能
30.4.4  未来的工作
30.5  小结
致谢
参考文献
 
第31章  使用实时纹理压缩进行游戏内视频捕捉
31.1  简介
31.2  DXT压缩概述
31.3  DXT压缩算法
31.4  转换为YUV格式颜色空间
31.5  比较
31.6  对程序内容和视频捕捉使用实时DXT压缩
31.6.1  使用YUYV-DXT压缩的视频捕捉
31.6.2  带宽因素
31.6.3  视频流的格式
31.6.4  从GPU下载视频帧
31.7  小结
参考文献
 
第32章  OpenGL友好几何文件格式及其Maya导出器
32.1  简介
32.2  背景知识
32.2.1  目标和特性
32.2.2  现有格式
32.3  关于Drone格式
32.3.1  二进制布局
32.3.2  Drone  API
32.3.3  场景API
32.4  编写Maya文件转换器
32.4.1  Maya  SDK基础知识
32.4.2  编写转换器
32.4.3  遍历Maya  DAG
32.4.4  导出可供OpenGL使用的网格
32.5  结果
32.6  小结
参考文献
 
第6篇  调试和性能分析
第33章  开发人员的强力臂助：ARB_debug_output
33.1  简介
33.2  公开扩展
33.3  使用回调函数
33.4  通过事件原因排序
33.5  访问消息日志
33.6  将自定义用户事件添加到日志中
33.7  控制事件输出量
33.8  防止对*终版本的影响
33.9  巨头之间的争斗：实现策略
33.10  关于调试的进一步思考
33.11  小结
参考文献
 
第34章  OpenGL计时器查询
34.1  简介
34.2  测量OpenGL执行时间
34.2.1  关于OpenGL时间
34.2.2  同步计时器查询
34.2.3  异步计时器查询
34.2.4  异步时间戳查询
34.2.5  考虑查询检索
34.3  小结
参考文献
 
第35章  实时性能分析工具
35.1  简介
35.2  范围和要求
35.3  工具设计
35.3.1  用户界面
35.3.2  限制和解决方法
35.3.3  应用程序编程接口
35.4  实现
35.4.1  测量CPU上的时间
35.4.2  测量GPU上的时间
35.4.3  数据结构
35.4.4  标记管理
35.5  使用性能分析程序
35.5.1  使用级别
35.5.2  确定应测量的内容
35.5.3  艺术设计师
35.5.4  局限性
35.6  小结
参考文献
 
第36章  浏览器图形分析和优化
36.1  简介
36.2  发光效果的阶段
36.3  发光效果的开销
36.4  分析WebGL应用程序
36.4.1  近乎原生的图形层引擎
36.4.2  JavaScript性能分析
36.4.3  WebGL  Inspector
36.4.4  英特尔图形性能分析器
36.5  Windows上的分析工作流程
36.6  优化发光效果
36.6.1  较低的渲染目标分辨率
36.6.2  不必要的Mipmap生成
36.6.3  浮点帧缓冲区
36.7  小结
参考文献
 
第37章  性能状态跟踪
37.1  简介
37.2  功耗策略
37.3  使用NVAPI进行P状态跟踪
37.3.1  关于GPU利用率
37.3.2  读取P状态
37.4  使用ADL进行P状态跟踪
37.5  小结
参考文献
 
第38章  图形内存使用情况监控
38.1  简介
38.2  图形内存分配
38.3  查询NVIDIA显卡的内存状态
38.4  查询AMD显卡的内存状态
38.5  小结
参考文献
 
第7篇  软件设计
第39章  ANGLE项目：在Direct3D上实现OpenGL  ES  2.
39.1  简介
39.2  背景
39.3  实现
39.3.1  坐标系
39.3.2  着色器编译器和链接器
39.3.3  顶点和索引缓冲区
39.3.4  纹理
39.3.5  顶点纹理提取
39.3.6  图元类型
39.3.7  蒙版清除
39.3.8  单独的深度和模板缓冲区
39.3.9  同步
39.3.10  多重采样
39.3.11  多个上下文和资源共享
39.3.12  上下文丢失
39.3.13  资源限制
39.3.14  优化
39.3.15  推荐做法
39.3.16  性能结果
39.4  未来工作
39.5  小结
39.6  源代码
致谢
参考文献
 
第40章  SceneJS：基于WebGL的场景图形引擎
40.1  简介
40.2  有效抽象WebGL
40.2.1  绘制列表编译
40.2.2  状态排序
40.3  优化场景
40.3.1  纹理图集
40.3.2  VBO共享
40.3.3  可共享的节点核心
40.4  拾取
40.5  小结
参考文献
 
第41章  SpiderGL中的特性和设计选择
41.1  简介
41.2  库架构
41.3  表示3D对象
41.4  直接访问WebGL对象状态
41.4.1  问题
41.4.2  解决方案
41.4.3  使用SGL_current_binding
41.4.4  使用SGL_direct_state_access
41.4.5  缺点
41.5  WebGLObject包装器
41.6  小结
致谢
参考文献
 
第42章  Web上的多模态交互式模拟
42.1  简介
42.2  关于?-SoFMIS模块的设计和定义
42.3  框架实现
42.3.1  模态
42.3.2  着色器
42.3.3  文件格式
42.4  渲染模块
42.5  模拟模块
42.6  硬件模块
42.7  案例研究：LAGB模拟器
42.8  小结
参考文献
 
第43章  使用OpenGL和OpenGL  ES的子集方法
43.1  简介
43.2  使陈旧的代码现代化
43.2.1  立即模式和顶点属性数组
43.2.2  图元选择
43.2.3  位图和多边形点画
43.3  保持代码在API变体中的可维护性
43.3.1  顶点和片段处理
43.3.2  GLX和EGL
43.3.3  顶点数组对象
43.3.4  线框模式
43.3.5  纹理包装模式
43.3.6  非2的n次幂
43.3.7  图像格式和类型
43.3.8  图像布局
43.3.9  着色语言
43.4  特定功能的代码块
43.5  小结
参考文献
 
第44章  构建跨平台应用程序
44.1  简介
44.2  使用实用程序库
44.2.1  使用GLUT的示例
44.2.2  使用Qt的示例
44.2.3  使用EGL的示例
44.3  与OpenGL版本无关的代码
44.4  配置空间
44.5  关于Metabuilds和CMake
44.6  关于CMake和配置空间
44.7  关于CMake和平台细节
44.7.1  平台：Windows
44.7.2  平台：Mac  OS  X
44.7.3  平台：iOS
44.8  小结
 
参考文献
