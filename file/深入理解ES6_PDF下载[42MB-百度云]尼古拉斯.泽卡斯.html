深入理解ES6 PDF下载 尼古拉斯.泽卡斯 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712131798
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712131798
<p>书名:深入理解ES6</p><p>作者:尼古拉斯.泽卡斯</p><p>页数:372</p><p>定价:¥99.0</p><p>出版社:电子工业出版社</p><p>出版日期:2017-07-01</p><p>ISBN:9787121317989</p><p><h2>本书特色</h2></p>[<p>
ES6是迄今为止JavaScript内核首当其冲的一次重大更新。本书是领域大家Nicholas C. Zakas撰写的一份ES6的完整指南，书中详细讲解了ES 6在JavaScript对象类型、语法及其他方面激动人心的改变。每一章都含有可运行于任何JavaScript环境的示例代码，你可以利用这些代码测试、理解ES6中的新功能。无论你是Web开发者还是Node.js开发者，都可以通过本书来更好地理解和运用ES6，或是顺利地从ES5迁移到ES6。
                                        </p>]<p><h2>内容简介</h2></p>[<p>√
不识老尼，枉为前端攻城狮，其成名作《JS高级程序设计》曾名动江湖。
√ Redux缔造者与React核心成员作序力荐，盛赞本书对JS的剖析无人企及。
√
用直截了当的方式传达艰深的技术细节，对技术的理解方可高效送达。
√
中高级开发者藉由本书可一举迈入对标准及其未来特性熟稔于心之化境。 </p>]<p><h2>作者简介</h2></p>[<p> Nicholas C. Zakas自2000年以来一直致力于Web应用程序的开发，重点关注前端开发，并以写作和讲述前沿*实践而闻名。他曾于雅虎主页任职5年有余，他也是多本书的作者，其中包括The Principles of Object-Oriented JavaScript（No Starch
Press出版社）和Professional JavaScript for Web Developers（Wrox出版社）。
 
关于技术评审
Juriy Zaytsev（在网上以kangax著称）是纽约的一位前端网站开发人员。自2007年以来，他一直在探索JavaScript的怪异特性并撰写相关文章。Juriy为多个开源项目做出过贡献，其中包括Prototype.js和其他的热门项目，如他自己的Fabric.js。他是按需定制打印服务printio.ru的共同创始人，目前任职于Facebook。
<br/>刘振涛，腾讯前端工程师；infoQ 网站资深译者，负责重点连载专栏《深入浅出ES6》；长期关注Web开发领域新生，尤其是 Ecma* 6；爱好摄影、网球，重度信息癖（Infomania）患者。</p>]<p><h2>目录</h2></p>
    第1章 块级作用域绑定 1var声明及变量提升（Hoisting）机制 1块级声明 3-- let声明 3-- 禁止重声明 4-- const声明 4-- 临时死区（Temporal Dead Zone） 6循环中的块作用域绑定 7-- 循环中的函数 8-- 循环中的let声明 9-- 循环中的const声明 10全局块作用域绑定 12块级绑定*佳实践的进化 13小结 13第2章 字符串和正则表达式 14更好的Unicode支持 14-- UTF-16码位 15-- codePointAt()方法 16-- String.fromCodePoint()方法 17-- normalize()方法 17-- 正则表达式u修饰符 19其他字符串变更 21-- 字符串中的子串识别 21-- repeat()方法 22其他正则表达式语法变更 23-- 正则表达式y修饰符 23-- 正则表达式的复制 26-- flags属性 27模板字面量 28-- 基础语法 28-- 多行字符串 29-- 字符串占位符 31-- 标签模板 32小结 36第3章 函数 37函数形参的默认值 37-- 在ECMAScript 5中模拟默认参数 38-- ECMAScript 6中的默认参数值 38-- 默认参数值对arguments对象的影响 40-- 默认参数表达式 42-- 默认参数的临时死区 44处理无命名参数 46-- ECMAScript 5中的无命名参数 46-- 不定参数 47增强的Function构造函数 49展开运算符 50name属性 52-- 如何选择合适的名称 52-- name属性的特殊情况 52明确函数的多重用途 54-- 在ECMAScript 5中判断函数被调用的方法 54-- 元属性（Metaproperty）new.target 55块级函数 57-- 块级函数的使用场景 58-- 非严格模式下的块级函数 58箭头函数 59-- 箭头函数语法 60-- 创建立即执行函数表达式 62-- 箭头函数没有this绑定 63-- 箭头函数和数组 65-- 箭头函数没有arguments绑定 66-- 箭头函数的辨识方法 66尾调用优化 67-- ECMAScript 6中的尾调用优化 68-- 如何利用尾调用优化 69小结 71第4章 扩展对象的功能性 72对象类别 72对象字面量语法扩展 73-- 属性初始值的简写 73-- 对象方法的简写语法 74-- 可计算属性名（Computed Property Name） 75新增方法 76-- Object.is()方法 76-- Object.assign()方法 77重复的对象字面量属性 80自有属性枚举顺序 81增强对象原型 82-- 改变对象的原型 82-- 简化原型访问的Super引用 83正式的方法定义 86小结 88第5章 解构：使数据访问更便捷 89为何使用解构功能 89对象解构 90-- 解构赋值 91-- 默认值 92-- 为非同名局部变量赋值 93-- 嵌套对象解构 94数组解构 96-- 解构赋值 97-- 默认值 99-- 嵌套数组解构 99-- 不定元素 99混合解构 101解构参数 102-- 必须传值的解构参数 103-- 解构参数的默认值 104小结 106第6章 Symbol和Symbol属性 107创建Symbol 107Symbol的使用方法 109Symbol共享体系 110Symbol与类型强制转换 112Symbol属性检索 112通过well-known Symbol暴露内部操作 113-- Symbol.hasInstance方法 114-- Symbol.isConcatSpreadable属性 116-- Symbol.match、Symbol.replace、Symbol.search和Symbol.split属性 118-- Symbol.toPrimitive方法 120-- Symbol.toStringTag属性 122-- Symbol.unscopables属性 125小结 127第7章 Set集合与Map集合 128ECMAScript 5中的Set集合与Map集合 129该解决方案的一些问题 129ECMAScript 6中的Set集合 131-- 创建Set集合并添加元素 131-- 移除元素 133-- Set集合的forEach()方法 133-- 将Set集合转换为数组 136-- Weak Set集合 136ECMAScript 6中的Map集合 139-- Map集合支持的方法 140-- Map集合的初始化方法 141-- Map集合的forEach()方法 142-- Weak Map集合 143小结 147第8章 迭代器（Iterator）和生成器（Generator） 149循环语句的问题 149什么是迭代器 150什么是生成器 151-- 生成器函数表达式 153-- 生成器对象的方法 154可迭代对象和for-of循环 155-- 访问默认迭代器 156-- 创建可迭代对象 157内建迭代器 158-- 集合对象迭代器 158-- 字符串迭代器 163-- NodeList迭代器 164展开运算符与非数组可迭代对象 165高级迭代器功能 166-- 给迭代器传递参数 166-- 在迭代器中抛出错误 168-- 生成器返回语句 170-- 委托生成器 171异步任务执行 174-- 简单任务执行器 174-- 向任务执行器传递数据 176-- 异步任务执行器 177小结 180第9章 JavaScript中的类 181ECMAScript 5中的近类结构 181类的声明 182-- 基本的类声明语法 182-- 为何使用类语法 184类表达式 186-- 基本的类表达式语法 186-- 命名类表达式 187作为一等公民的类 189访问器属性 190可计算成员名称 192生成器方法 193静态成员 195继承与派生类 196-- 类方法遮蔽 199-- 静态成员继承 199-- 派生自表达式的类 200-- 内建对象的继承 203-- Symbol.species属性 205在类的构造函数中使用new.target 208小结 210第10章 改进的数组功能 211创建数组 211-- Array.of()方法 212-- Array.from()方法 213为所有数组添加的新方法 216-- find()方法和findIndex()方法 217-- fill()方法 217-- copyWithin()方法 218定型数组 219-- 数值数据类型 220-- 数组缓冲区 221-- 通过视图操作数组缓冲区 221定型数组与普通数组的相似之处 228-- 通用方法 229-- 相同的迭代器 230-- of()方法和from()方法 230定型数组与普通数组的差别 231-- 行为差异 231-- 缺失的方法 232-- 附加方法 233小结 234第11章 Promise与异步编程 235异步编程的背景知识 235-- 事件模型 236-- 回调模式 236Promise的基础知识 239-- Promise的生命周期 239-- 创建未完成的Promise 242-- 创建已处理的Promise 244-- 执行器错误 247全局的Promise拒绝处理 248Node.js环境的拒绝处理 248浏览器环境的拒绝处理 251串联Promise 253-- 捕获错误 254-- Promise链的返回值 255-- 在Promise链中返回Promise 256响应多个Promise 259-- Promise.all()方法 259-- Promise.race()方法 260自Promise继承 262基于Promise的异步任务执行 263小结 267第12章 代理（Proxy）和反射（Reflection）API 269数组问题 269代理和反射 270创建一个简单的代理 271使用set陷阱验证属性 272用get陷阱验证对象结构（Object Shape） 274使用has陷阱隐藏已有属性 275用deleteProperty陷阱防止删除属性 277原型代理陷阱 279-- 原型代理陷阱的运行机制 279-- 为什么有两组方法 281对象可扩展性陷阱 282-- 两个基础示例 283-- 重复的可扩展性方法 284属性描述符陷阱 285-- 给Object.defineProperty()添加限制 286-- 描述符对象限制 287-- 重复的描述符方法 288ownKeys陷阱 290函数代理中的apply和construct陷阱 291-- 验证函数参数 292-- 不用new调用构造函数 294-- 覆写抽象基类构造函数 296-- 可调用的类构造函数 297可撤销代理 298解决数组问题 299-- 检测数组索引 300-- 添加新元素时增加length的值 300-- 减少length的值来删除元素 302-- 实现MyArray类 304将代理用作原型 307-- 在原型上使用get陷阱 307-- 在原型上使用set陷阱 308-- 在原型上使用has陷阱 309-- 将代理用作类的原型 310小结 314第13章 用模块封装代码 315什么是模块 315导出的基本语法 316导入的基本语法 317-- 导入单个绑定 318-- 导入多个绑定 318-- 导入整个模块 318-- 导入绑定的一个微妙怪异之处 320导出和导入时重命名 320模块的默认值 321-- 导出默认值 321-- 导入默认值 322重新导出一个绑定 323无绑定导入 324加载模块 325-- 在Web浏览器中使用模块 325-- 浏览器模块说明符解析 329小结 330附录A ECMAScript 6中较小的改动 331附录B 了解ECMAScript 7（2016） 337索引 343
