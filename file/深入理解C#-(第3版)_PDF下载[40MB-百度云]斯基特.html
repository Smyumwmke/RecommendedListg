深入理解C#-(第3版) PDF下载 斯基特 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711534642
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711534642
<p>书名:深入理解C#-(第3版)</p><p>作者:斯基特</p><p>页数:490</p><p>定价:¥99.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2014-04-01</p><p>ISBN:9787115346421</p><p><h2>相关资料</h2></p>[<p>“学习c#语言特性的最佳资源。”——andy kirsch，venga<br/>
<br/>
“本书使我的c#水平更上一层楼。”——dustin laine，code harvest<br/>
<br/>
“每一位.net开发人员都至少应该阅读一遍的案头必备图书。”———dror helper，better place<br/>
<br/>
“本书无疑是我读过的最佳c#参考书。”——jon parish，datasift<br/></p>]<p><h2>本书特色</h2></p>[<p>
《深入理解c#(第3版)》是c#领域不可多得的经典著作。作者在详尽地展示c#各个知识点的同时，更注重从现象中挖掘本质。《深入理解c#(第3版)》深入探索了c#的核心概念和经典特性，并将这些特性融入到代码中，让读者能够真正领会到c#之“深入”与“精妙”。在第2版的基础上，《深入理解c#(第3版)》新增了c# 5的新特性——异步，并更新了随着技术的发展，已经不再适用的内容，确保整本书能达到读者期望的高标准。
　　如果你略微了解一点c#，就可无障碍地阅读《深入理解c#(第3版)》。
                                        </p>]<p><h2>内容简介</h2></p>[<p>资深c# mvp扛鼎之作
　　深入理解语言特性，探究本源
　　net开发人员必读经典</p>]<p><h2>作者简介</h2></p>[<p>Jon Skeet
　　谷歌软件工程师，微软资深C# MVP，拥有10余年C#项目开发经验。自2002年以来，他一直是C#社区、新闻组、国际会议和Stack Overflow网站上非常活跃的技术专家，回答了数以万计的C#和.NET相关问题。</p>]<p><h2>目录</h2></p>
    **部分　基础知识　第1章　c#开发的进化史　　　1．1　从简单的数据类型开始　　　1．1．1　c# 1中定义的产品类型　　　1．1．2　c# 2中的强类型集合　　　1．1．3　c# 3中自动实现的属性　　　1．1．4　c# 4中的命名实参　　　1．2　排序和过滤　　　1．2．1　按名称对产品进行排序　　　1．2．2　查询集合　　　1．3　处理未知数据　　　1．3．1　表示未知的价格　　　1．3．2　可选参数和默认值　　　1．4　linq简介　　　1．4．1　查询表达式和进程内查询　　　1．4．2　查询xml　　　1．4．3　linq to sql　　　1．5　com和动态类型　　　1．5．1　简化com互操作　　　1．5．2　与动态语言互操作　　　1．6　轻松编写异步代码　　　1．7　剖析．net平台　　　1．7．1　c#语言　　　1．7．2　运行时　　　1．7．3　框架库　　　1．8　怎样写出超炫的代码　　　1．8．1　采用代码段形式的全能代码　　　1．8．2　教学代码不是产品代码　　　1．8．3　你的新朋友：语言规范　　　1．9　小结　　第2章　c# 1所搭建的核心基础　　　2．1　委托　　　2．1．1　简单委托的构成　　　2．1．2　合并和删除委托　　　2．1．3　对事件的简单讨论　　　2．1．4　委托总结　　　2．2　类型系统的特征　　　2．2．1　c#在类型系统世界中的位置　　　2．2．2　c# 1的类型系统何时不够用　　　2．2．3　类型系统特征总结　　　2．3　值类型和引用类型　　　2．3．1　现实世界中的值和引用　　　2．3．2　值类型和引用类型基础知识　　　2．3．3　走出误区　　　2．3．4　装箱和拆箱　　　2．3．5　值类型和引用类型小结　　　2．4　c# 1之外：构建于坚实基础之上的新特性　　　2．4．1　与委托有关的特性　　　2．4．2　与类型系统有关的特性　　　2．4．3　与值类型有关的特性　　　2．5　小结　第二部分　c# 2：解决c# 1的问题　第3章　用泛型实现参数化类型　　　3．1　为什么需要泛型　　　3．2　日常使用的简单泛型　　　3．2．1　通过例子来学习：泛型字典　　　3．2．2　泛型类型和类型参数　　　3．2．3　泛型方法和判读泛型声明　　　3．3　深化与提高　　　3．3．1　类型约束　　　3．3．2　泛型方法类型实参的类型推断　　　3．3．3　实现泛型　　　3．4　高级泛型　　　3．4．1　静态字段和静态构造函数　　　3．4．2　jit编译器如何处理泛型　　　3．4．3　泛型迭代　　　3．4．4　反射和泛型　　　3．5　泛型在c#和其他语言中的限制　　　3．5．1　泛型可变性的缺乏　　　3．5．2　缺乏操作符约束或者“数值”约束　　　3．5．3　缺乏泛型属性、索引器和其他成员类型　　　3．5．4　同c++模板的对比　　　3．5．5　和java泛型的对比　　　3．6　小结　　第4章　可空类型　　　4．1　没有值时怎么办　　　4．1．1　为什么值类型的变量不能是null　　　4．1．2　在c# 1中表示空值的模式　　　4．2　system．nullable和system．nullable　　　4．2．1　nullable简介　　　4．2．2　nullable装箱和拆箱　　　4．2．3　nullable实例的相等性　　　4．2．4　来自非泛型nullable类的支持　　　4．3　c# 2为可空类型提供的语法糖　　　4．3．1　?修饰符　　　4．3．2　使用null进行赋值和比较　　　4．3．3　可空转换和操作符　　　4．3．4　可空逻辑　　　4．3．5　对可空类型使用as操作符　　　4．3．6　空合并操作符　　　4．4　可空类型的新奇用法　　　4．4．1　尝试一个不使用输出参数的操作　　　4．4．2　空合并操作符让比较不再痛苦　　　4．5　小结　　第5章　进入快速通道的委托　　　5．1　向笨拙的委托语法说拜拜　　　5．2　方法组转换　　　5．3　协变性和逆变性　　　5．3．1　委托参数的逆变性　　　5．3．2　委托返回类型的协变性　　　5．3．3　不兼容的风险　　　5．4　使用匿名方法的内联委托操作　　　5．4．1　从简单的开始：处理一个参数　　　5．4．2　匿名方法的返回值　　　5．4．3　忽略委托参数　　　5．5　匿名方法中的捕获变量　　　5．5．1　定义闭包和不同类型的变量　　　5．5．2　捕获变量的行为　　　5．5．3　捕获变量到底有什么用处　　　5．5．4　捕获变量的延长生存期　　　5．5．5　局部变量实例化　　　5．5．6　共享和非共享的变量混合使用　　　5．5．7　捕获变量的使用规则和小结　　　5．6　小结　　第6章　实现迭代器的捷径　　　6．1　c# 1：手写迭代器的痛苦　　　6．2　c# 2：利用yield语句简化迭代器　　　6．2．1　迭代器块和yield return简介　　　6．2．2　观察迭代器的工作流程　　　6．2．3　进一步了解迭代器执行流程　　　6．2．4　具体实现中的奇特之处　　　6．3　真实的迭代器示例　　　6．3．1　迭代时刻表中的日期　　　6．3．2　迭代文件中的行　　　6．3．3　使用迭代器块和谓词对项进行延迟过滤　　　6．4　使用ccr实现伪同步代码　　　6．5　小结　　第7章　结束c# 2的讲解：*后的一些特性　　　7．1　分部类型　　　7．1．1　在多个文件中创建一个类型　　　7．1．2　分部类型的使用　　　7．1．3　c# 3独有的分部方法　　　7．2　静态类型　　　7．3　独立的取值方法/赋值方法属性访问器　　　7．4　命名空间别名　　　7．4．1　限定的命名空间别名　　　7．4．2　全局命名空间别名　　　7．4．3　外部别名　　　7．5　pragma指令　　　7．5．1　警告pragma　　　7．5．2　校验和pragma　　　7．6　非安全代码中固定大小的缓冲区　　　7．7　把内部成员暴露给选定的程序集　　　7．7．1　简单情况下的友元程序集　　　7．7．2　为什么使用internals-visibleto　　　7．7．3　internalsvisibleto和签名程序集　　　7．8　小结　第三部分　c# 3：革新写代码的方式　第8章　用智能的编译器来防错　　　8．1　自动实现的属性　　　8．2　隐式类型的局部变量　　　8．2．1　用var声明局部变量　　　8．2．2　隐式类型的限制　　　8．2．3　隐式类型的优缺点　　　8．2．4　建议　　　8．3　简化的初始化　　　8．3．1　定义示例类型　　　8．3．2　设置简单属性　　　8．3．3　为嵌入对象设置属性　　　8．3．4　集合初始化程序　　　8．3．5　初始化特性的应用　　　8．4　隐式类型的数组　　　8．5　匿名类型　　　8．5．1　**次邂逅匿名类型　　　8．5．2　匿名类型的成员　　　8．5．3　投影初始化程序　　　8．5．4　重点何在　　　8．6　小结　　第9章　lambda表达式和表达式树　　　9．1　作为委托的lambda表达式　　　9．1．1　准备工作：func<．．．>委托类型简介　　　9．1．2　**次转换成lambda表达式　　　9．1．3　用单一表达式作为主体　　　9．1．4　隐式类型的参数列表　　　9．1．5　单一参数的快捷语法　　　9．2　使用list和事件的简单例子　　　9．2．1　列表的过滤、排序和操作　　　9．2．2　在事件处理程序中进行记录　　　9．3　表达式树　　　9．3．1　以编程方式构建表达式树　　　9．3．2　将表达式树编译成委托　　　9．3．3　将c# lambda表达式转换成表达式树　　　9．3．4　位于linq核心的表达式树　　　9．3．5　linq之外的表达式树　　　9．4　类型推断和重载决策的改变　　　9．4．1　改变的起因：精简泛型方法调用　　　9．4．2　推断匿名函数的返回类型　　　9．4．3　分两个阶段进行的类型推断　　　9．4．4　选择正确的被重载的方法　　　9．4．5　类型推断和重载决策　　　9．5　小结　　第10章　扩展方法　　　10．1　未引入扩展方法之前的状态　　　10．2　扩展方法的语法　　　10．2．1　声明扩展方法　　　10．2．2　调用扩展方法　　　10．2．3　扩展方法是怎样被发现的　　　10．2．4　在空引用上调用方法　　　10．3　．net 3．5中的扩展方法　　　10．3．1　从enumerable开始起步　　　10．3．2　用where过滤并将方法调用链接到一起　　　10．3．3　插曲：似曾相识的where方法　　　10．3．4　用select方法和匿名类型进行投影　　　10．3．5　用orderby方法进行排序　　　10．3．6　涉及链接的实际例子　　　10．4　使用思路和原则　　　10．4．1 “扩展世界”和使接口更丰富　　　10．4．2　流畅接口　　　10．4．3　理智使用扩展方法　　　10．5　小结　　第11章　查询表达式和linq to objects　　　11．1　linq介绍　　　11．1．1　linq中的基础概念　　　11．1．2　定义示例数据模型　　　11．2　简单的开始：选择元素　　　11．2．1　以数据源作为开始，以选择作为结束　　　11．2．2　编译器转译是查询表达式基础的转译　　　11．2．3　范围变量和重要的投影　　　11．2．4　cast、oftype和显式类型的范围变量　　　11．3　对序列进行过滤和排序　　　11．3．1　使用where子句进行过滤　　　11．3．2　退化的查询表达式　　　11．3．3　使用orderby子句进行排序　　　11．4　let子句和透明标识符　　　11．4．1　用let来进行中间计算　　　11．4．2　透明标识符　　　11．5　连接　　　11．5．1　使用join子句的内连接　　　11．5．2　使用join．．．into子句进行分组连接　　　11．5．3　使用多个from子句进行交叉连接和合并序列　　　11．6　分组和延续　　　11．6．1　使用group．．．by子句进行分组　　　11．6．2　查询延续　　　11．7　在查询表达式和点标记之间作出选择　　　11．7．1　需要使用点标记的操作　　　11．7．2　使用点标记可能会更简单的查询表达式　　　11．7．3　选择查询表达式　　　11．8　小结　　第12章　超越集合的linq　　　12．1　使用linq to sql查询数据库　　　12．1．1　数据库和模型　　　12．1．2　用查询表达式访问数据库　　　12．1．3　包含连接的查询　　　12．2　用iqueryable和iqueryprovider进行转换　　　12．2．1　iqueryable和相关接口的介绍　　　12．2．2　模拟接口实现来记录调用　　　12．2．3　把表达式粘合在一起：queryable的扩展方法　　　12．2．4　模拟实际运行的查询提供器　　　12．2．5　包装iqueryable　　　12．3　linq友好的api和linq to xml　　　12．3．1　linq to xml中的核心类型　　　12．3．2　声明式构造　　　12．3．3　查询单个节点　　　12．3．4　合并查询操作符　　　12．3．5　与linq和谐共处　　　12．4　用并行linq代替linq to objects　　　12．4．1　在单线程中绘制曼德博罗特集　　　12．4．2　parallelenumerable、parallelquery和asparallel　　　12．4．3　调整并行查询　　　12．5　使用linq to rx反转查询模型　　　12．5．1　iobservable和iobserver　　　12．5．2　简单的开始　　　12．5．3　查询可观察对象　　　12．5．4　意义何在　　　12．6　扩展linq to objects　　　12．6．1　设计和实现指南　　　12．6．2　示例扩展：选择随机元素　　　12．7　小结　第四部分　c# 4：良好的交互性　第13章　简化代码的微小修改　　　13．1　可选参数和命名实参　　　13．1．1　可选参数　　　13．1．2　命名实参　　　13．1．3　两者相结合　　　13．2　改善com互操作性　　　13．2．1　在c# 4之前操纵word是十分恐怖的　　　13．2．2　可选参数和命名实参的复仇　　　13．2．3　按值传递ref参数　　　13．2．4　调用命名索引器　　　13．2．5　链接主互操作程序集　　　13．3　接口和委托的泛型可变性　　　13．3．1　可变性的种类：协变性和逆变性　　　13．3．2　在接口中使用可变性　　　13．3．3　在委托中使用可变性　　　13．3．4　复杂情况　　　13．3．5　限制和说明　　　13．4　对锁和字段风格的事件的微小改变　　　13．4．1　健壮的锁　　　13．4．2　字段风格的事件　　　13．5　小结　　第14章　静态语言中的动态绑定　　　14．1　何谓、何时、为何、如何　　　14．1．1　何谓动态类型　　　14．1．2　动态类型什么时候有用，为什么　　　14．1．3　c# 4如何提供动态类型　　　14．2　关于动态的快速指南　　　14．3　动态类型示例　　　14．3．1　com和office　　　14．3．2　动态语言　　　14．3．3　纯托管代码中的动态类型　　　14．4　幕后原理　　　14．4．1　dlr简介　　　14．4．2　dlr核心概念　　　14．4．3　c#编译器如何处理动态　　　14．4．4　更加智能的c#编译器　　　14．4．5　动态代码的约束　　　14．5　实现动态行为　　　14．5．1　使用expandoobject　　　14．5．2　使用dynamicobject　　　14．5．3　实现idynamicmetaobject-provider　　　14．6　小结　第五部分　c# 5：简化的异步编程　第15章　使用async/await进行异步编程　　　15．1　异步函数简介　　　15．1．1　初识异步类型　　　15．1．2　分解**个示例　　　15．2　思考异步编程　　　15．2．1　异步执行的基础　　　15．2．2　异步方法　　　15．3　语法和语义　　　15．3．1　声明异步方法　　　15．3．2　异步方法的返回类型　　　15．3．3　可等待模式　　　15．3．4　await表达式的流　　　15．3．5　从异步方法返回　　　15．3．6　异常　　　15．4　异步匿名函数　　　15．5　实现细节：编译器转换　　　15．5．1　生成的代码　　　15．5．2　骨架方法的结构　　　15．5．3　状态机的结构　　　15．5．4　一个入口搞定一切　　　15．5．5　围绕await表达式的控制　　　15．5．6　跟踪栈　　　15．5．7　更多内容　　　15．6　高效地使用async/await　　　15．6．1　基于任务的异步模式　　　15．6．2　组合异步操作　　　15．6．3　对异步代码编写单元测试　　　15．6．4　可等待模式的归来　　　15．6．5　在winrt中执行异步操作　　　15．7　小结　　第16章　c# 5附加特性和结束语　　　16．1　foreach循环中捕获变量的变化　　　16．2　调用者信息特性　　　16．2．1　基本行为　　　16．2．2　日志　　　16．2．3　实现inotifyproperty-changed　　　16．2．4　在非．net 4．5环境下使用调用者信息特性　　　16．3　结束语　　　附录a　linq标准查询操作符　　　附录b　．net中的泛型集合　　　附录c　版本总结
