深入理解Scala PDF下载 苏瑞茨 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711536554
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711536554
<p>书名:深入理解Scala</p><p>作者:苏瑞茨</p><p>页数:274</p><p>定价:¥59.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2015-01-01</p><p>ISBN:9787115365545</p><p><h2>相关资料</h2></p>[<p>“权威并且易于理解”。<br/>
　　——martinoderskyscala之父<br/>
　　“带你深入scala的内部工作机制”。<br/>
　　——johnctylerprospricing<br/>
　　“目前为止，我在技术书里读到过的最好的示例”。<br/>
　　——ericweinbergwaggerdesigns<br/>
　　“一本开拓眼界的书，现在我对scala知其所以然了”。<br/>
　　——johncriffinhibernatesearchinaction合著者</p>]<p><h2>本书特色</h2></p>[<p>
scala是一种多范式的编程语言，它既支持面向对象编程，也支持函数式编程的各种特性。
本书深入探讨了scala里几个较为复杂的领域，包括类型系统的高阶内容、隐式转换、特质的组合技巧、集合、actor、函数式编程的范畴论等，而且不是干巴巴地讲述语言和库的概念。本书充满各种实用的建议和*佳实践，可以来帮助读者学习怎样把scala里较少被掌握的部分应用到工作中。 
　　本书不是scala的入门级教程，而是适合有经验的scala程序员向专家水平进阶的参考读物。本书适合想要了解scala语言的底层机制和技术细节的读者阅读参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>scala是一种强大的jvm语言，混合了函数式和面向对象编程范式。你很容易通过图书和上网找到scala 的介绍性资料，但是很难找到来自资深实践者的深刻洞见和代码示例，而本书可以满足你的需要。本书没有什么棘手的理论——只包含众多新鲜、实用的scala编程技巧。本书适合用于了解java、scala或其他面向对象语言的读者。</p>]<p><h2>作者简介</h2></p>[<p>Josh Suereth 是Typesafe公司的一名软件工程师，它是Scala的Committer之一，也是scala-tools.org的维护者。</p>]<p><h2>目录</h2></p>
	第1章 scala--一种混合式编程语言 　1.1 scala的设计哲学 　1.2 当函数式编程遇见面向对象 　　1.2.1 重新发现函数式概念 　　1.2.2 google collections中的函数式概念 　1.3 静态类型和表达力 　　1.3.1 换边 　　1.3.2 类型推断 　　1.3.3 抛开语法 　　1.3.4 隐式转换概念早已有之 　　1.3.5 使用scala的implicit关键字 　1.4 与jvm的无缝集成 　　1.4.1 scala调用java 　　1.4.2 java调用scala 　　1.4.3 jvm的优越性 　1.5 总结 第2章 核心规则 　2.1 学习使用scala交互模式（repl） 　　2.1.1 实验驱动开发 　　2.1.2 绕过积极（eaglerly）解析 　　2.1.3 无法表现的语言特性 　2.2 优先采用面向表达式编程 　　2.2.1 方法和模式匹配 　　2.2.2 可变性 　2.3 优先选择不变性 　　2.3.1 判等 　　2.3.2 并发 　2.4 用none不用null 　2.5 多态场景下的判等 　　2.5.1 例子：时间线库 　　2.5.2 多态判等实现 　2.6 总结 第3章 来点样式-编码规范 　3.1 避免照搬其他语言的编码规范 　3.2 空悬的操作符和括号表达式 　3.3 使用有意义的命名 　　3.3.1 命名时避免$符号 　　3.3.2 使用命名和默认参数 　3.4 总是标记覆盖（overriden）方法 　3.5 对期望的优化进行标注 　3.6 总结 第4章 面向对象编程 　4.1 限制在对象或特质的body里初始化逻辑的代码 　　4.1.1 延迟构造 　　4.12 多重继承又来了 　4.2 为特质的抽象方法提供空实现 　4.3 组合可以包含继承 　　4.3.1 通过继承组合成员 　　4.3.2 经典构造器with a twist 　　4.3.3 总结 　4.4 提升抽象接口为独立特质 　　4.4.1 和接口交互 　　4.4.2 从历史中吸取教训 　　4.4.3 结论 　4.5 public接口应当提供返回值 　4.6 总结 第5章 利用隐式转换写更有表达力 　5.1 介绍隐式转换系统 　　5.1.1 题外话：标识符 　　5.1.2 作用域和绑定 　　5.1.3 隐式解析 　　5.1.4 通过类型参数获得隐式作用域 　　5.1.5 通过嵌套获得隐式作用域 　5.2 隐式视图：强化已存在的类 　5.3 隐式参数结合默认参数 　5.4 限制隐式系统的作用域 　　5.4.1 为导入创建隐式转换 　　5.4.2 没有导入税（import tax）的隐式转换 　5.5 总结 第6章 类型系统 　6.1 类型 　　6.1.1 类型和路径 　　6.1.2 type关键字 　　6.1.3 结构化类型 　6.2 类型约束 　6.3 类型参数和高阶类型（higher kindedtypes） 　　6.3.1 类型参数约束 　　6.3.2 高阶类型 　6.4 型变（variance） 　6.5 存在类型 　6.6 总结 第7章 隐式转换和类型系统结合应用 　7.1 上下文边界和视图边界 　7.2 用隐式转换来捕捉类型 　　7.2.1 捕获类型用于运行时计算（capturing types for runtime evaluation） 　　7.2.2 使用manifest 　　7.2.3 捕捉类型约束 　　7.2.4 特定方法（specializedmethod）　7.3 使用类型类（type class） 　　7.3.1 作为类型类的filelike 　　7.3.2 类型类的好处 　7.4 用类型系统实现条件执行 　　7.4.1 异构类型list 　　7.4.2 indexedview 　7.5 总结 第8章 scala集合库 　8.1 使用正确的集合类型 　　8.1.1 集合库继承层次 　　8.1.2 traversable 　　8.1.3 iterable 　　8.1.4 seq 　　8.1.5 linearseq 　　8.1.6 indexedseq 　　8.1.7 set 　　8.1.8 map 　8.2 不可变集合 　　8.2.1 vector 　　8.2.2 list 　　8.2.3 stream（流） 　8.3 可变集合 　　8.3.1 arraybuffer 　　8.3.2 混入修改事件发布特质 　　8.3.3 混入串行化特质 　8.4 用视图和并行集合来改变计算策略 　　8.4.1 视图 　　8.4.2 并行集合 　8.5 编写能处理所有集合类型的方法 　8.6 总结 第9章 actors 　9.1 使用actor的时机 　9.2 使用有类型的、透明的引用 　9.3 把故障限制在故障区里 　　9.3.1 发散搜集故障区 　　9.3.2 通常的故障处理实践 　9.4 利用排期区控制负载 　9.5 动态actor拓扑 　9.6 总结 第10章 scala和java集成 　10.1 scala/java不匹配 　　10.1.1 基础类型自动打包的差异 　　10.1.2 可见性的差异 　　10.1.3 不可表达的语言特性 　10.2 谨慎使用隐式转换 　　10.2.1对象标识和判等 　　10.2.2 链式隐式转换 　10.3 小心java序列化 　10.4 注解你的注解 　　10.4.1 注解目标 　　10.4.2 scala和静态属性 　10.5 总结 第11章 函数式编程 　11.1 计算机科学领域的范畴论 　11.2 函子（functor），monad及它们与范畴的关系 　11.3 咖喱化和可应用风格（applicative style） 　　11.3.1 咖喱化 　　11.3.2 可应用风格 　11.4 用作工作流的单子 　11.5 总结
