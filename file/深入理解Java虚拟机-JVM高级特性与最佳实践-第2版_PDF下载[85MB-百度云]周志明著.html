深入理解Java虚拟机-JVM高级特性与最佳实践-第2版 PDF下载 周志明著 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711142190
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711142190
<p>书名:深入理解Java虚拟机-JVM高级特性与最佳实践-第2版</p><p>作者:周志明　著</p><p>页数:433</p><p>定价:¥79.0</p><p>出版社:机械工业出版社</p><p>出版日期:2013-06-01</p><p>ISBN:9787111421900</p><p><h2>节选</h2></p>[<p>《深入理解Java虚拟机:JVM高级特性与*佳实践(第2版)》编辑推荐:超级畅销书全新升级,第1版两年内印刷近10次,Java图书领域公认的经典著作,繁体版台湾发行。基于*新JDK1.7,围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行全面而深入的分析,深刻揭示JVM的工作原理。<br/>以实践为导向,通过大量与实际生产环境相结合的案例展示了解决各种常见JVM问题的技巧和*佳实践。</p>]<p><h2>内容简介</h2></p>[<p>
                                    
                                        
本书第1版两年内印刷近10次，4家网上书店的评论近4?000条，98%以上的评论全部为5星级的好评，是整个java图书领域公认的经典著作和超级畅销书，繁体版在台湾也十分受欢迎。第2版在第1版的基础上做了很大的改进：根据*新的jdk
1.7对全书内容进行了全面的升级和补充；增加了大量处理各种常见jvm问题的技巧和*佳实践；增加了若干与生产环境相结合的实战案例；对第1版中的错误和不足之处的修正；等等。第2版不仅技术更新、内容更丰富，而且实战性更强。


全书共分为五大部分，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对jvm进行了全面而深入的分析，深刻揭示了jvm的工作原理。**部分从宏观的角度介绍了整个java技术体系、java和jvm的发展历程、模块化，以及jdk的编译，这对理解本书后面内容有重要帮助。第二部分讲解了jvm的自动内存管理，包括虚拟机内存区域的划分原理以及各种内存溢出异常产生的原因；常见的垃圾收集算法以及垃圾收集器的特点和工作原理；常见虚拟机监控与故障处理工具的原理和使用方法。第三部分分析了虚拟机的执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎。第四部分讲解了程序的编译与代码的优化，阐述了泛型、自动装箱拆箱、条件编译等语法糖的原理；讲解了虚拟机的热点探测方法、hotspot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析jit编译的数据和结果；第五部分探讨了java实现高效并发的原理，包括jvm内存模型的结构和操作；原子性、可见性和有序性在java内存模型中的体现；先行发生原则的规则和使用；线程在java语言中的实现原理；虚拟机实现高效并发所做的一系列锁优化措施。                                    </p>]<p><h2>目录</h2></p>
前言**部分　走近java第1章　走近java1.1　概述1.2　java技术体系1.3　java发展史1.4　java虚拟机发展史1.4.1　sun classic exact vm1.4.2　sun hotspot vm1.4.3　sun mobile-embedded vm meta-circular vm1.4.4　bea jrockit ibm j9 vm1.4.5　azul vm bea liquid vm1.4.6　apache harmony google android dalvik vm1.4.7　microsoft jvm及其他1.5　展望java技术的未来1.5.1　模块化1.5.2　混合语言1.5.3　多核并行1.5.4　进一步丰富语法1.5.5　64位虚拟机1.6　实战：自己编译jdk1.6.1　获取jdk源码1.6.2　系统需求1.6.3　构建编译环境1.6.4　进行编译1.6.5　在ide工具中进行源码调试1.7　本章小结第二部分　自动内存管理机制第2章　java内存区域与内存溢出异常2.1　概述2.2　运行时数据区域2.2.1　程序计数器2.2.2　java虚拟机栈2.2.3　本地方法栈2.2.4　java堆2.2.5　方法区2.2.6　运行时常量池2.2.7　直接内存2.3　hotspot虚拟机对象探秘2.3.1　对象的创建2.3.2　对象的内存布局2.3.3　对象的访问定位2.4　实战：outofmemoryerror异常2.4.1　java堆溢出2.4.2　虚拟机栈和本地方法栈溢出2.4.3　方法区和运行时常量池溢出2.4.4　本机直接内存溢出2.5　本章小结第3章　垃圾收集器与内存分配策略3.1　概述3.2　对象已死吗3.2.1　引用计数算法3.2.2　可达性分析算法3.2.3　再谈引用3.2.4　生存还是死亡3.2.5　回收方法区3.3　垃圾收集算法3.3.1　标记-清除算法3.3.2　复制算法3.3.3　标记-整理算法3.3.4　分代收集算法3.4　hotspot的算法实现3.4.1　枚举根节点3.4.2　安全点3.4.3　安全区域3.5　垃圾收集器3.5.1　serial收集器3.5.2　parnew收集器3.5.3　parallel scavenge收集器3.5.4　serial old收集器3.5.5　parallel old收集器3.5.6　cms收集器3.5.7　g1收集器3.5.8　理解gc日志3.5.9　垃圾收集器参数总结3.6　内存分配与回收策略3.6.1　对象优先在eden分配3.6.2　大对象直接进入老年代3.6.3　长期存活的对象将进入老年代3.6.4　动态对象年龄判定3.6.5　空间分配担保3.7　本章小结第4章　虚拟机性能监控与故障处理工具4.1　概述4.2　jdk的命令行工具4.2.1　jps：虚拟机进程状况工具4.2.2　jstat：虚拟机统计信息监视工具4.2.3　jinfo：java配置信息工具4.2.4　jmap：java内存映像工具4.2.5　jhat：虚拟机堆转储快照分析工具4.2.6　jstack：java堆栈跟踪工具4.2.7　hsdis：jit生成代码反汇编4.3　jdk的可视化工具4.3.1　jconsole：java监视与管理控制台4.3.2　visualvm：多合一故障处理工具4.4　本章小结第5章　调优案例分析与实战5.1　概述5.2　案例分析5.2.1　高性能硬件上的程序部署策略5.2.2　集群间同步导致的内存溢出5.2.3　堆外内存导致的溢出错误5.2.4　外部命令导致系统缓慢5.2.5　服务器jvm进程崩溃5.2.6　不恰当数据结构导致内存占用过大5.2.7　由windows虚拟内存导致的长时间停顿5.3　实战：eclipse运行速度调优5.3.1　调优前的程序运行状态5.3.2　升级jdk 1.6的性能变化及兼容问题5.3.3　编译时间和类加载时间的优化5.3.4　调整内存设置控制垃圾收集频率5.3.5　选择收集器降低延迟5.4　本章小结第三部分　虚拟机执行子系统第6章　类文件结构6.1　概述6.2　无关性的基石6.3　class类文件的结构6.3.1　魔数与class文件的版本6.3.2　常量池6.3.3　访问标志6.3.4　类索引、父类索引与接口索引集合6.3.5　字段表集合6.3.6　方法表集合6.3.7　属性表集合6.4　字节码指令简介6.4.1　字节码与数据类型6.4.2　加载和存储指令6.4.3　运算指令6.4.4　类型转换指令6.4.5　对象创建与访问指令6.4.6　操作数栈管理指令6.4.7　控制转移指令6.4.8　方法调用和返回指令6.4.9　异常处理指令6.4.10　同步指令6.5　公有设计和私有实现6.6　class文件结构的发展6.7　本章小结第7章　虚拟机类加载机制7.1　概述7.2　类加载的时机7.3　类加载的过程7.3.1　加载7.3.2　验证7.3.3　准备7.3.4　解析7.3.5　初始化7.4　类加载器7.4.1　类与类加载器7.4.2　双亲委派模型7.4.3　破坏双亲委派模型7.5　本章小结第8章　虚拟机字节码执行引擎8.1　概述8.2　运行时栈帧结构8.2.1　局部变量表8.2.2　操作数栈8.2.3　动态连接8.2.4　方法返回地址8.2.5　附加信息8.3　方法调用8.3.1　解析8.3.2　分派8.3.3　动态类型语言支持8.4　基于栈的字节码解释执行引擎8.4.1　解释执行8.4.2　基于栈的指令集与基于寄存器的指令集8.4.3　基于栈的解释器执行过程8.5　本章小结第9章　类加载及执行子系统的案例与实战9.1　概述9.2　案例分析9.2.1　tomcat：正统的类加载器架构9.2.2　osgi：灵活的类加载器架构9.2.3　字节码生成技术与动态代理的实现9.2.4　retrotranslator：跨越jdk版本9.3　实战：自己动手实现远程执行功能9.3.1　目标9.3.2　思路9.3.3　实现9.3.4　验证9.4　本章小结第四部分　程序编译与代码优化第10章　早期（编译期）优化10.1　概述10.2　javac编译器10.2.1　javac的源码与调试10.2.2　解析与填充符号表10.2.3　注解处理器10.2.4　语义分析与字节码生成10.3　java语法糖的味道10.3.1　泛型与类型擦除10.3.2　自动装箱、拆箱与遍历循环10.3.3　条件编译10.4　实战：插入式注解处理器10.4.1　实战目标10.4.2　代码实现10.4.3　运行与测试10.4.4　其他应用案例10.5　本章小结第11章　晚期（运行期）优化11.1　概述11.2　hotspot虚拟机内的即时编译器11.2.1　解释器与编译器11.2.2　编译对象与触发条件11.2.3　编译过程11.2.4　查看及分析即时编译结果11.3　编译优化技术11.3.1　优化技术概览11.3.2　公共子表达式消除11.3.3　数组边界检查消除11.3.4　方法内联11.3.5　逃逸分析11.4　java与cc++的编译器对比11.5　本章小结第五部分　高效并发第12章　java内存模型与线程12.1　概述12.2　硬件的效率与一致性12.3　java内存模型12.3.1　主内存与工作内存12.3.2　内存间交互操作12.3.3　对于volatile型变量的特殊规则12.3.4　对于long和double型变量的特殊规则12.3.5　原子性、可见性与有序性12.3.6　先行发生原则12.4　java与线程12.4.1　线程的实现12.4.2　java线程调度12.4.3　状态转换12.5　本章小结第13章　线程安全与锁优化13.1　概述13.2　线程安全13.2.1　java语言中的线程安全13.2.2　线程安全的实现方法13.3　锁优化13.3.1　自旋锁与自适应自旋13.3.2　锁消除13.3.3　锁粗化13.3.4　轻量级锁13.3.5　偏向锁13.4　本章小结附　　录附录a　编译windows版的openjdk附录b　虚拟机字节码指令表附录c　hotspot虚拟机主要参数表附录d　对象查询语言（oql）简介附录e　jdk历史版本轨迹                            
