游戏编程模式 PDF下载 尼斯卓姆 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542688
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542688
<p>书名:游戏编程模式</p><p>作者:尼斯卓姆</p><p>页数:306</p><p>定价:¥69.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-09-01</p><p>ISBN:9787115426888</p><p><h2>本书特色</h2></p>[<p>
游戏开发一直是热门的领域，掌握良好的游戏编程模式是开发人员的应备技能。本书细致地讲解了游戏开发需要用到的各种编程模式，并提供了丰富的示例。
全书共分20章，通过三大部分内容全面介绍了与游戏编程模式相关的各类知识点。首部分介绍了基础知识和框架；第二部分深入探索设计模式，并介绍了模式与游戏开发之间的关联；第三部分介绍了13种有效的游戏设计模式。
本书提供了丰富的代码示例，通过理论和代码示例相结合的方式帮助读者更好地学习。无论是游戏领域的设计人员、开发人员，还是想要进入游戏开发领域的学生和普通程序员，都可以阅读本书。
                                        </p>]<p><h2>内容简介</h2></p>[<p>前ea杰出游戏工程师经验凝结4大类13种游戏编程模式精彩呈现
多数游戏程序员所面临的挑战就是实现他们的游戏。许多游戏在其高度复杂的代码库中折戟沉沙，没能问世。本书是为解决此问题而生。本书作者在多年的游戏开发工作中，收集了许多已经证实的设计模式来帮助解构、重构以及优化游戏。
通过阅读本书，你将深刻理解经典的设计模式是如何应用于游戏之中的，学会如何编写一个健壮的游戏循环、如何应用组件来组织实体，并利用cpu缓存来提升游戏性能。
本书包含的4大类13种游戏编程模式包括：
序列型模式
● 双缓冲
● 游戏循环
● 更新方法
优化型模式
● 数据局部性
● 脏标记模型
● 对象池
● 空间分区
行为型模式
● 字节码
● 子类沙盒
● 类型对象
解耦型模式
● 组件模式
● 事件队列
● 服务定位器 </p>]<p><h2>作者简介</h2></p>[<p>Robert Nystrom是一位拥有2 0 年以上职业编程经验的开发者，而他在其中大概一半的时间从事游戏开发。在艺电（El e c t r o n i c Arts）的8年时间里，他曾参与劲爆美式足球（Madden）系列这样庞大的项目，也曾投身于亨利·海茨沃斯大冒险（Henry Hatsworth in the Puzzling Adventure）这样稍小规模的游戏开发之中。他所开发的游戏遍及PC、GameCube、PS2、XBox、X360以及DS平台。但他引以为傲的，是为开发者们提供了开发工具和共享库。他热衷于寻求易用的、漂亮的代码来延伸和增强开发者们的创造力。Robert与他的妻子和两个女儿定居于西雅图，在那里你很有可能会见到他正在为朋友们下厨，或者在为他们上啤酒。</p>]<p><h2>目录</h2></p>
    目录第1篇　概述第1章　架构，性能和游戏　31.1　什么是软件架构　31.1.1　什么是好的软件架构　31.1.2　你如何做出改变　41.1.3　我们如何从解耦中受益　51.2　有什么代价　51.3　性能和速度　61.4　坏代码中的好代码　71.5　寻求平衡　81.6　简单性　91.7　准备出发　9第2篇　再探设计模式第2章　命令模式　132.1　配置输入　142.2　关于角色的说明　162.3　撤销和重做　182.4　类风格化还是函数风格化　212.5　参考　22第3章　享元模式　233.1　森林之树　233.2　一千个实例　253.3　享元模式　263.4　扎根之地　263.5　性能表现如何　303.6　参考　31第4章　观察者模式　334.1　解锁成就　334.2　这一切是怎么工作的　344.2.1　观察者　354.2.2　被观察者　354.2.3　可被观察的物理模块　374.3　它太慢了　384.4　太多的动态内存分配　394.4.1　链式观察者　394.4.2　链表节点池　424.5　余下的问题　434.5.1　销毁被观察者和观察者　434.5.2　不用担心，我们有gc　444.5.3　接下来呢　444.6　观察者模式的现状　454.7　观察者模式的未来　46第5章　原型模式　475.1　原型设计模式　475.1.1　原型模式效果如何　505.1.2　生成器函数　515.1.3　模板　515.1.4　头等公民类型（first-class types）　525.2　原型语言范式　525.2.1　self 语言　535.2.2　结果如何　545.2.3　javascript如何　555.3　原型数据建模　57第6章　单例模式　616.1　单例模式　616.1.1　确保一个类只有一个实例　616.1.2　提供一个全局指针以访问唯一实例　626.2　使用情境　636.3　后悔使用单例的原因　656.3.1　它是一个全局变量　656.3.2　它是个画蛇添足的解决方案　666.3.3　延迟初始化剥离了你的控制　676.4　那么我们该怎么做　686.4.1　看你究竟是否需要类　686.4.2　将类限制为单一实例　706.4.3　为实例提供便捷的访问方式　716.5　剩下的问题　73第7章　状态模式　757.1　我们曾经相遇过　757.2　救星：有限状态机　787.3　枚举和分支　797.4　状态模式　827.4.1　一个状态接口　827.4.2　为每一个状态定义一个类　837.4.3　状态委托　847.5　状态对象应该放在哪里呢　847.5.1　静态状态　847.5.2　实例化状态　857.6　进入状态和退出状态的行为　867.7　有什么收获吗　887.8　并发状态机　887.9　层次状态机　897.10　下推自动机　917.11　现在知道它们有多有用了吧　92第3篇　序列型模式第8章　双缓冲　958.1　动机　958.1.1　计算机图形系统是如何工作的（概述）　958.1.2　**幕，**场　968.1.3　回到图形上　978.2　模式　988.3　使用情境　988.4　注意事项　988.4.1　交换本身需要时间　988.4.2　我们必须有两份缓冲区　998.5　示例代码　998.5.1　并非只针对图形　1028.5.2　人工非智能　1028.5.3　缓存这些巴掌　1068.6　设计决策　1078.6.1　缓冲区如何交换　1078.6.2　缓冲区的粒度如何　1098.7　参考　110第9章　游戏循环　1119.1　动机　1119.1.1　cpu探秘　1119.1.2　事件循环　1129.1.3　时间之外的世界　1139.1.4　秒的长短　1139.2　模式　1149.3　使用情境　1149.4　使用须知　1149.5　示例代码　1159.5.1　跑，能跑多快就跑多快　1159.5.2　小睡一会儿　1159.5.3　小改动，大进步　1169.5.4　把时间追回来　1189.5.5　留在两帧之间　1199.6　设计决策　1209.6.1　谁来控制游戏循环，你还是平台　1219.6.2　你如何解决能量耗损　1219.6.3　如何控制游戏速度　1229.7　参考　1
