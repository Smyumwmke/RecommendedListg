深入理解计算机系统-原书第3版 PDF下载 兰德尔E.布莱恩特 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711154493
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711154493
<p>书名:深入理解计算机系统-原书第3版</p><p>作者:兰德尔E.布莱恩特</p><p>页数:737</p><p>定价:¥139.0</p><p>出版社:机械工业出版社</p><p>出版日期:2016-11-01</p><p>ISBN:9787111544937</p><p><h2>本书特色</h2></p>[<p>
和第2版相比，本版内容上*大的变化是，从以IA32和x86-64为基础转变为完全以x86-64为基础。主要更新如下：<br/>
• 基于x86-64，大量地重写代码，首次介绍对处理浮点数据的程序的机器级支持。<br/>
• 处理器体系结构修改为支持64位字和操作的设计。<br/>
• 引入更多的功能单元和更复杂的控制逻辑，使基于程序数据流表示的程序性能模型预测更加可靠。<br/>
• 扩充关于用GOT和PLT创建与位置无关代码的讨论，描述了更加强大的链接技术（比如库打桩）。<br/>
• 增加了对信号处理程序更细致的描述，包括异步信号安全的函数等。<br/>
• 采用*新函数，更新了与协议无关和线程安全的网络编程。
                                        </p>]<p><h2>内容简介</h2></p>[<p>1.第二版销售突破100000册，第三版重磅上市！<br/>
2.理解计算机系统*书目， 10余万程序员的共同选择<br/>
3.卡内基-梅隆、北京大学、清华大学、上海交通大学等国内外众多知名高校选用指定教材<br/>
4.从程序员视角全面剖析的实现细节，使读者深刻理解程序的行为，将所有计算机系统的相关知识融会贯通。<br/>
5.新版本全面基于X86-64位处理器<br/>
6.全新的阅读和学习体验：由国内名师录制章前导读，使读者可以了解各章的重点内容和知识关联，形成关于计算机系统的知识架构。并开设了本书的网络社区，读者可加入社区，获得本书相关学习资源，了解活动信息。
 </p>]<p><h2>作者简介</h2></p>[<p>Randal E. Bryant   1981年于麻省理工学院获得计算机博士学位，1984年至今一直任教于卡内基-梅隆大学。现任卡内基-梅隆大学计算机科学学院院长、教授，同时还受邀任教于电子和计算机工程系。他从事本科生和研究生计算机系统方面课程的教学近40年。他和O’Hallaron教授一起在卡内基梅隆大学开设了15-213课程“计算机系统导论”，那便是本书的基础。他还是ACM院士、IEEE院士、美国国家工程院院士和美国人文与科学研究院院士。其研究成果被Intel、IBM、Fujitsu和Microsoft等主要计算机制造商使用，他还因研究获得过Semiconductor Research Corporation、ACM、IEEE颁发的多项大奖。<br/><br/>David R. O’Hallaron卡内基梅隆大学电子和计算机工程系教授。在弗吉尼亚大学（University of Virginia）获得计算机科学的博士学位，2007年-2010年为Intel匹兹堡实验室主任。他教授本科生和研究生的计算机系统方面的课程已有20余年，并和Bryant教授一起开设了“计算机系统导论”课程。曾获得CMU计算机学院颁发的Herbert Simon杰出教学奖。他主要从事计算机系统领域的研究，与Quake项目成员一起获得过高性能计算领域中的最高国际奖项——Gordon Bell奖。他目前的工作重点是研究自动分级（autograding）概念，即评价其他程序质量的程序。Randal E. Bryant   1981年于麻省理工学院获得计算机博士学位，1984年至今一直任教于卡内基-梅隆大学。现任卡内基-梅隆大学计算机科学学院院长、教授，同时还受邀任教于电子和计算机工程系。他从事本科生和研究生计算机系统方面课程的教学近40年。他和O’Hallaron教授一起在卡内基梅隆大学开设了15-213课程“计算机系统导论”，那便是本书的基础。他还是ACM院士、IEEE院士、美国国家工程院院士和美国人文与科学研究院院士。其研究成果被Intel、IBM、Fujitsu和Microsoft等主要计算机制造商使用，他还因研究获得过Semiconductor Research Corporation、ACM、IEEE颁发的多项大奖。<br/>
<br/>
David R. O’Hallaron卡内基梅隆大学电子和计算机工程系教授。在弗吉尼亚大学（University of Virginia）获得计算机科学的博士学位，2007年-2010年为Intel匹兹堡实验室主任。他教授本科生和研究生的计算机系统方面的课程已有20余年，并和Bryant教授一起开设了“计算机系统导论”课程。曾获得CMU计算机学院颁发的Herbert Simon杰出教学奖。他主要从事计算机系统领域的研究，与Quake项目成员一起获得过高性能计算领域中的最高国际奖项——Gordon Bell奖。他目前的工作重点是研究自动分级（autograding）概念，即评价其他程序质量的程序。
 
基于该教材的北大“计算机系统导论”课程实施已有五年，得到了学生的广泛赞誉，学生们通过这门课程的学习建立了完整的计算机系统的知识体系和整体知识框架，养成了良好的编程习惯并获得了编写高性能、可移植和健壮的程序的能力，奠定了后续学习操作系统、编译、计算机体系结构等专业课程的基础。北大的教学实践表明，这是一本值得推荐采用的好教材。本书第3版采用最新x86-64架构来贯穿各部分知识。我相信，该书的出版将有助于国内计算机系统教学的进一步改进，为培养从事系统级创新的计算机人才奠定很好的基础。<br/>
—— 梅 宏 中国科学院院士/发展中国家科学院院士<br/>
<br/>
以低年级开设“深入理解计算机系统”课程为基础，我先后在复旦大学和上海交通大学软件学院主导了激进的教学改革……现在我课题组的青年教师全部是首批经历此教学改革的学生。本科的扎实基础为他们从事系统软件的研究打下了良好的基础……师资力量的补充又为推进更加激进的教学改革创造了条件。<br/>
—— 臧斌宇 上海交通大学软件学院院长信息</p>]<p><h2>目录</h2></p>
    出版者的话中文版序一中文版序二译者序前言关于作者第1章　计算机系统漫游1　1.1　信息就是位 上下文1　1.2　程序被其他程序翻译成不同的格式3　1.3　了解编译系统如何工作是大有益处的4　1.4　处理器读并解释储存在内存中的指令5　　1.4.1　系统的硬件组成5　　1.4.2　运行hello程序7　1.5　高速缓存至关重要9出版者的话
中文版序一
中文版序二
译者序
前言
关于作者
第1章　计算机系统漫游11.1　信息就是位 上下文11.2　程序被其他程序翻译成不同的格式31.3　了解编译系统如何工作是大有益处的41.4　处理器读并解释储存在内存中的指令51.4.1　系统的硬件组成51.4.2　运行hello程序71.5　高速缓存至关重要91.6　存储设备形成层次结构91.7　操作系统管理硬件101.7.1　进程111.7.2　线程121.7.3　虚拟内存121.7.4　文件141.8　系统之间利用网络通信141.9　重要主题161.9.1　Amdahl定律161.9.2　并发和并行171.9.3　计算机系统中抽象的重要性191.10　小结20参考文献说明20练习题答案20
**部分
程序结构和执行第2章　信息的表示和处理222.1　信息存储242.1.1　十六进制表示法252.1.2　字数据大小272.1.3　寻址和字节顺序292.1.4　表示字符串342.1.5　表示代码342.1.6　布尔代数简介352.1.7　C语言中的位级运算372.1.8　C语言中的逻辑运算392.1.9　C语言中的移位运算402.2　整数表示412.2.1　整型数据类型422.2.2　无符号数的编码432.2.3　补码编码442.2.4　有符号数和无符号数之间的转换492.2.5　C语言中的有符号数与无符号数522.2.6　扩展一个数字的位表示542.2.7　截断数字562.2.8　关于有符号数与无符号数的建议582.3　整数运算602.3.1　无符号加法602.3.2　补码加法622.3.3　补码的非662.3.4　无符号乘法672.3.5　补码乘法672.3.6　乘以常数702.3.7　除以2的幂712.3.8　关于整数运算的*后思考742.4　浮点数752.4.1　二进制小数762.4.2　IEEE浮点表示782.4.3　数字示例792.4.4　舍入832.4.5　浮点运算852.4.6　C语言中的浮点数862.5　小结87参考文献说明88家庭作业88练习题答案97
第3章　程序的机器级表示1093.1　历史观点1103.2　程序编码1133.2.1　机器级代码1133.2.2　代码示例1143.2.3　关于格式的注解1173.3　数据格式1193.4　访问信息1193.4.1　操作数指示符1213.4.2　数据传送指令1223.4.3　数据传送示例1253.4.4　压入和弹出栈数据1273.5　算术和逻辑操作1283.5.1　加载有效地址1293.5.2　一元和二元操作1303.5.3　移位操作1313.5.4　讨论1313.5.5　特殊的算术操作1333.6　控制1353.6.1　条件码1353.6.2　访问条件码1363.6.3　跳转指令1383.6.4　跳转指令的编码1393.6.5　用条件控制来实现条件分支…1413.6.6　用条件传送来实现条件分支…1453.6.7　循环1493.6.8　switch语句1593.7　过程1643.7.1　运行时栈1643.7.2　转移控制1653.7.3　数据传送1683.7.4　栈上的局部存储1703.7.5　寄存器中的局部存储空间1723.7.6　递归过程1743.8　数组分配和访问1763.8.1　基本原则1763.8.2　指针运算1773.8.3　嵌套的数组1783.8.4　定长数组1793.8.5　变长数组1813.9　异质的数据结构1833.9.1　结构1833.9.2　联合1863.9.3　数据对齐1893.10　在机器级程序中将控制与数据结合起来1923.10.1　理解指针1923.10.2　应用：使用GDB调试器1933.10.3　内存越界引用和缓冲区溢出1943.10.4　对抗缓冲区溢出攻击1983.10.5　支持变长栈帧2013.11　浮点代码2043.11.1　浮点传送和转换操作2053.11.2　过程中的浮点代码2093.11.3　浮点运算操作2103.11.4　定义和使用浮点常数2123.11.5　在浮点代码中使用位级操作2123.11.6　浮点比较操作2133.11.7　对浮点代码的观察结论2153.12　小结216参考文献说明216家庭作业216练习题答案226
第4章　处理器体系结构2434.1　Y86-64指令集体系结构2454.1.1　程序员可见的状态2454.1.2　Y86-64指令2454.1.3　指令编码2464.1.4　Y86-64异常2504.1.5　Y86-64程序2514.1.6　一些Y86-64指令的详情2554.2　逻辑设计和硬件控制语言HCL2564.2.1　逻辑门2574.2.2　组合电路和HCL布尔表达式2574.2.3　字级的组合电路和HCL整数表达式2584.2.4　集合关系2614.2.5　存储器和时钟2624.3　Y86-64的顺序实现2644.3.1　将处理组织成阶段2644.3.2　SEQ硬件结构2724.3.3　SEQ的时序2744.3.4　SEQ阶段的实现2774.4　流水线的通用原理2824.4.1　计算流水线2824.4.2　流水线操作的详细说明2844.4.3　流水线的局限性2844.4.4　带反馈的流水线系统2874.5　Y86-64的流水线实现2884.5.1　SEQ ：重新安排计算阶段2884.5.2　插入流水线寄存器2894.5.3　对信号进行重新排列和标号2924.5.4　预测下一个PC2934.5.5　流水线冒险2954.5.6　异常处理3064.5.7　PIPE各阶段的实现3084.5.8　流水线控制逻辑3144.5.9　性能分析3224.5.10　未完成的工作3234.6　小结325参考文献说明326家庭作业327练习题答案331
第5章　优化程序性能3415.1　优化编译器的能力和局限性3425.2　表示程序性能3455.3　程序示例3475.4　消除循环的低效率3505.5　减少过程调用3535.6　消除不必要的内存引用3545.7　理解现代处理器3575.7.1　整体操作3575.7.2　功能单元的性能3615.7.3　处理器操作的抽象模型3625.8　循环展开3665.9　提高并行性3695.9.1　多个累积变量3705.9.2　重新结合变换3735.10　优化合并代码的结果小结3775.11　一些限制因素3785.11.1　寄存器溢出3785.11.2　分支预测和预测错误处罚3795.12　理解内存性能3825.12.1　加载的性能3825.12.2　存储的性能3835.13　应用：性能提高技术3875.14　确认和消除性能瓶颈3885.14.1　程序剖析3885.14.2　使用剖析程序来指导优化3905.15　小结392参考文献说明393家庭作业393练习题答案395
第6章　存储器层次结构3996.1　存储技术3996.1.1　随机访问存储器4006.1.2　磁盘存储4066.1.3　固态硬盘4146.1.4　存储技术趋势4156.2　局部性4186.2.1　对程序数据引用的局部性4186.2.2　取指令的局部性4196.2.3　局部性小结4206.3　存储器层次结构4216.3.1　存储器层次结构中的缓存4226.3.2　存储器层次结构概念小结4246.4　高速缓存存储器4256.4.1　通用的高速缓存存储器组织结构4256.4.2　直接映射高速缓存4276.4.3　组相联高速缓存4336.4.4　全相联高速缓存4346.4.5　有关写的问题4376.4.6　一个真实的高速缓存层次结构的解剖4386.4.7　高速缓存参数的性能影响4396.5　编写高速缓存友好的代码4406.6　综合：高速缓存对程序性能的影响4446.6.1　存储器山4446.6.2　重新排列循环以提高空间局部性4476.6.3　在程序中利用局部性4506.7　小结450参考文献说明451家庭作业451练习题答案459
第二部分
在系统上运行程序第7章　链接4647.1　编译器驱动程序4657.2　静态链接4667.3　目标文件4667.4　可重定位目标文件4677.5　符号和符号表4687.6　符号解析4707.6.1　链接器如何解析多重定义的全局符号4717.6.2　与静态库链接4757.6.3　链接器如何使用静态库来解析引用4777.7　重定位4787.7.1　重定位条目4797.7.2　重定位符号引用4797.8　可执行目标文件4837.9　加载可执行目标文件4847.10　动态链接共享库4857.11　从应用程序中加载和链接共享库4877.12　位置无关代码4897.13　库打桩机制4927.13.1　编译时打桩4927.13.2　链接时打桩4927.13.3　运行时打桩4947.14　处理目标文件的工具4967.15　小结496参考文献说明497家庭作业497练习题答案499
第8章　异常控制流5018.1　异常5028.1.1　异常处理5038.1.2　异常的类别5048.1.3　Linux/x86-64系统中的异常5058.2　进程5088.2.1　逻辑控制流5088.2.2　并发流5098.2.3　私有地址空间5098.2.4　用户模式和内核模式5108.2.5　上下文切换5118.3　系统调用错误处理5128.4　进程控制5138.4.1　获取进程ID5138.4.2　创建和终止进程5138.4.3　回收子进程5168.4.4　让进程休眠5218.4.5　加载并运行程序5218.4.6　利用fork和execve运行程序5248.5　信号5268.5.1　信号术语5278.5.2　发送信号5288.5.3　接收信号5318.5.4　阻塞和解除阻塞信号5328.5.5　编写信号处理程序5338.5.6　同步流以避免讨厌的并发错误5408.5.7　显式地等待信号5438.6　非本地跳转5468.7　操作进程的工具5508.8　小结550参考文献说明550家庭作业550练习题答案556
第9章　虚拟内存5599.1　物理和虚拟寻址5609.2　地址空间5609.3　虚拟内存作为缓存的工具5619.3.1　DRAM缓存的组织结构5629.3.2　页表5629.3.3　页命中5639.3.4　缺页5649.3.5　分配页面5659.3.6　又是局部性救了我们5659.4　虚拟内存作为内存管理的工具5659.5　虚拟内存作为内存保护的工具5679.6　地址翻译5679.6.1　结合高速缓存和虚拟内存5709.6.2　利用TLB加速地址翻译5709.6.3　多级页表5719.6.4　综合：端到端的地址翻译5739.7　案例研究：Intel Core i7/Linux内存系统5769.7.1　Core i7地址翻译5769.7.2　Linux虚拟内存系统5809.8　内存映射5829.8.1　再看共享对象5839.8.2　再看fork函数5849.8.3　再看execve函数5849.8.4　使用mmap函数的用户级内存映射5859.9　动态内存分配5879.9.1　malloc和free函数5879.9.2　为什么要使用动态内存分配5899.9.3　分配器的要求和目标5909.9.4　碎片5919.9.5　实现问题5929.9.6　隐式空闲链表5929.9.7　放置已分配的块5939.9.8　分割空闲块5949.9.9　获取额外的堆内存5949.9.10　合并空闲块5949.9.11　带边界标记的合并5959.9.12　综合：实现一个简单的分配器5979.9.13　显式空闲链表6039.9.14　分离的空闲链表6049.10　垃圾收集6059.10.1　垃圾收集器的基本知识6069.10.2　Mark&Sweep垃圾收集器6079.10.3　C程序的保守Mark&Sweep6089.11　C程序中常见的与内存有关的错误6099.11.1　间接引用坏指针6099.11.2　读未初始化的内存6099.11.3　允许栈缓冲区溢出6109.11.4　假设指针和它们指向的对象是相同大小的6109.11.5　造成错位错误6119.11.6　引用指针，而不是它所指向的对象6119.11.7　误解指针运算6119.11.8　引用不存在的变量6129.11.9　引用空闲堆块中的数据6129.11.10　引起内存泄漏6139.12　小结613参考文献说明613家庭作业614练习题答案617
第三部分
程序间的交互和通信第10章　系统级I/O622　10.1　Unix I/O62210.2　文件62310.3　打开和关闭文件62410.4　读和写文件62510.5　用RIO包健壮地读写62610.5.1　RIO的无缓冲的输入输出函数62710.5.2　RIO的带缓冲的输入函数62710.6　读取文件元数据63210.7　读取目录内容63310.8　共享文件63410.9　I/O重定向63710.10　标准I/O63810.11　综合：我该使用哪些I/O函数？63810.12　小结640参考文献说明640家庭作业640练习题答案641
第11章　网络编程64211.1　客户端服务器编程模型64211.2　网络64311.3　全球IP因特网64611.3.1　IP地址64711.3.2　因特网域名64911.3.3　因特网连接65111.4　套接字接口65211.4.1　套接字地址结构65311.4.2　socket函数65411.4.3　connect函数65411.4.4　bind函数65411.4.5　listen函数65511.4.6　accept函数65511.4.7　主机和服务的转换65611.4.8　套接字接口的辅助函数66011.4.9　echo客户端和服务器的示例66211.5　Web服务器66511.5.1　Web基础66511.5.2　Web内容66611.5.3　HTTP事务66711.5.4　服务动态内容66911.6　综合：TINY Web服务器67111.7　小结678参考文献说明678家庭作业678练习题答案679
第12章　并发编程68112.1　基于进程的并发编程68212.1.1　基于进程的并发服务器68312.1.2　进程的优劣68412.2　基于I/O多路复用的并发编程68412.2.1　基于I/O多路复用的并发事件驱动服务器68612.2.2　I/O多路复用技术的优劣69012.3　基于线程的并发编程69112.3.1　线程执行模型69112.3.2　Posix线程69112.3.3　创建线程69212.3.4　终止线程69312.3.5　回收已终止线程的资源69312.3.6　分离线程69412.3.7　初始化线程69412.3.8　基于线程的并发服务器69412.4　多线程程序中的共享变量69612.4.1　线程内存模型69612.4.2　将变量映射到内存69712.4.3　共享变量69812.5　用信号量同步线程69812.5.1　进度图70112.5.2　信号量70212.5.3　使用信号量来实现互斥70312.5.4　利用信号量来调度共享资源70412.5.5　综合：基于预线程化的并发服务器70812.6　使用线程提高并行性71012.7　其他并发问题71612.7.1　线程安全71612.7.2　可重入性71712.7.3　在线程化的程序中使用已存在的库函数71812.7.4　竞争71912.7.5　死锁72112.8　小结722参考文献说明723家庭作业723练习题答案726
附录A　错误处理729
参考文献733信息
