深入解析Android虚拟机 PDF下载 钟世礼 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542353
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542353
<p>书名:深入解析Android虚拟机</p><p>作者:钟世礼</p><p>页数:595</p><p>定价:¥99.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-09-01</p><p>ISBN:9787115423535</p><p><h2>本书特色</h2></p>[<p>
Android系统从诞生到现在的短短几年时间里，凭借其易用性和开发的简洁性，赢得了广大开发者的支持。在整个Android系统中，Dalvik VM一直是贯穿从底层内核到高层应用开发的核心。本书循序渐进地讲解了Android虚拟机系统的基本知识，并剖析了其整个内存系统的进程和运作流程，并对虚拟机系统优化和异常处理的知识进行了详细讲解。本书几乎涵盖了Dalvik VM系统的所有主要内容，并且讲解方法通俗易懂，特别有利于读者学习并消化。
本书适合Android初学者、Android底层开发人员、源代码分析人员和虚拟机开发人员学习，也可以作为大专院校相关专业师生的学习用书和培训学校的教材。
                                        </p>]<p><h2>内容简介</h2></p>[<p>依次讲解了Java虚拟机基础、Android虚拟机基础
分析JNI、内存系统、Android程序的生命周期管理、IPC进程通信机制、init进程，讲解了Dalvik VM的进程系统和运作流程、Dvlik VM内存系统详解、Dalvik VM垃圾收集机制、Dalvik VM内存优化机制、Dalvik VM的启动过程、Dalvik VM异常处理，
以及Dalvik VM内存优化和Dalvik VM性能优化等内容。 </p>]<p><h2>作者简介</h2></p>[<p>计算机硕士，精通C、C  、Linux、Java开发技术，擅长多媒体硬件处理、多媒体信号采集、嵌入式系统集成、物联网、大数据等开发技术，对蓝牙技术、传感器、NFC数据传播、红外传输技术有独特的见解。毕业后就职于施耐德公司，负责智能家居系统的研究、开发和产品设计工作，和开发团队一起研究出多款功能强大的智能家居、健康仪器、智能电视、车载设备等大型系统。在Android底层架构和驱动开发方面有着丰富的经验，硬件驱动开发专家。</p>]<p><h2>目录</h2></p>
    目录第1章　获取并编译Android源码　11.1　获取Android源码　11.1.1　在Linux系统获取Android源码　11.1.2　在Windows平台获取Android源码　21.1.3　Windows获取Android L源码　41.2　分析Android源码结构　61.3　编译Android源码　81.3.1　搭建编译环境　81.3.2　开始编译　91.3.3　在模拟器中运行　10目录

第1章　获取并编译Android源码　1
1.1　获取Android源码　1
1.1.1　在Linux系统获取Android
源码　1
1.1.2　在Windows平台获取Android
源码　2
1.1.3　Windows获取Android L源码　4
1.2　分析Android源码结构　6
1.3　编译Android源码　8
1.3.1　搭建编译环境　8
1.3.2　开始编译　9
1.3.3　在模拟器中运行　10
1.3.4　常见的错误分析　10
1.3.5　实践演练—演示两种编译Android程序的方法　11
1.4　编译Android Kernel　14
1.4.1　获取Goldfish内核代码　14
1.4.2　获取MSM内核代码　17
1.4.3　获取OMAP内核代码　17
1.4.4　编译Android的Linux内核　17
第2章　Java虚拟机基础　19
2.1　虚拟机的作用　19
2.2　Java虚拟机概述　20
2.2.1　JVM的数据类型　20
2.2.2　Java虚拟机体系结构　21
2.2.3　JVM的生命周期　25
2.3　JVM的安全性　26
2.3.1　JVM的安全模型　26
2.3.2　沙箱模型的4种组件　27
2.3.3　分析Java的策略机制　28
2.4　网络移动性　29
2.4.1　现实需要网络移动性　29
2.4.2　网络移动性　30
2.5　内存异常和垃圾处理　31
2.5.1　内存分配中的栈和堆　31
2.5.2　运行时的数据区域　33
2.5.3　对象访问　34
2.5.4　内存泄露　35
2.5.5　JVM的垃圾收集策略　36
2.5.6　垃圾收集器　37
2.6　Java内存模型　37
2.6.1　Java内存模型概述　38
2.6.2　主内存与工作内存　38
2.6.3　内存间交互操作　39
第3章　Dalvik和ART基础　40
3.1　Dalvik VM和JVM的差异　40
3.2　Dalvik虚拟机的主要特征　41
3.3　Dalvik VM架构　42
3.3.1　Dalvik虚拟机的代码结构　42
3.3.2　dx工具　44
3.3.3　Dalvik VM的进程管理　44
3.3.4　Android的初始化流程　44
3.4　Dalvik VM控制VM命令详解　45
3.4.1　基本命令　45
3.4.2　扩展的JNI检测　45
3.4.3　断言　46
3.4.4　字节码校验和优化　46
3.4.5　Dalvik VM的运行模式　47
3.4.6　死锁预测　47
3.4.7　dump堆栈追踪　48
3.4.8　dex文件和校验　48
3.4.9　产生标志位　48
3.5　ART机制基础　48
3.5.1　什么是ART模式　48
3.5.2　ART优化机制基础　50
第4章　分析JNI　52
4.1　JNI的本质　52
4.2　分析Java层　54
4.2.1　加载JNI库　54
4.2.2　实现扫描工作　55
4.2.3　读取并保存信息　56
4.2.4　删除SD卡外的信息　58
4.2.5　直接转向JNI　58
4.2.6　扫描函数scanFile　59
4.2.7　JNI中的异常处理　59
4.3　分析JNI层　60
4.3.1　将Native对象的指针保存到
Java对象　60
4.3.2　创建Native层的MediaScanner
对象　60
4.4　Native（本地）层　61
4.4.1　注册JNI函数　61
4.4.2　完成注册工作　63
4.4.3　动态注册　64
4.4.4　处理路径参数　65
4.4.5　扫描文件　66
4.4.6　添加TAG信息　66
4.4.7　总结函数JNI_OnLoad()与函数JNI_OnUnload()的用途　67
4.4.8　Java与JNI基本数据类型
转换　67
4.4.9　JNIEnv接口　69
4.4.10　JNI中的环境变量　70
第5章　分析内存系统　71
5.1　分析Android的进程通信机制　71
5.1.1　Android的进程间通信（IPC）
机制Binder　71
5.1.2　Service Manager是Binder
机制的上下文管理者　72
5.1.3　Service Manager服务　86
5.2　匿名共享内存子系统详解　89
5.2.1　基础数据结构　89
5.2.2　初始化处理　90
5.2.3　打开匿名共享内存设备文件　91
5.2.4　内存映射　93
5.2.5　读写操作　94
5.2.6　锁定和解锁　95
5.2.7　回收内存块　100
5.3　C  访问接口层详解　101
5.3.1　接口MemoryBase　101
5.3.2　接口MemoryBase　108
5.4　Java访问接口层详解　111
第6章　Android程序的生命周期管理　115
6.1　Android程序的生命周期　115
6.1.1　进程和线程　115
6.1.2　进程的类型　116
6.2　Activity的生命周期　116
6.2.1　Activity的几种状态　117
6.2.2　分解剖析Activity　117
6.2.3　几个典型的场景　119
6.2.4　管理Activity的生命周期　119
6.2.5　Activity的实例化与启动　120
6.2.6　Activity的暂停与继续　120
6.2.7　Activity的关闭 销毁与
重新运行　121
6.2.8　Activity的启动模式　121
6.3　进程与线程　122
6.3.1　进程　122
6.3.2　线程　123
6.3.3　线程安全的方法　123
6.3.4　Android的线程模型　123
6.4　测试生命周期　125
6.5　Service的生命周期　129
6.5.1　Service的基本概念和用途　129
6.5.2　Service的生命周期详解　129
6.5.3　Service与Activity通信　129
6.6　Android广播的生命周期　133
6.6.1　Android 的广播机制　133
6.6.2　编写广播程序　133
6.7　ART进程管理　135
第7章　IPC进程通信机制　147
7.1　Binder机制概述　147
7.2　Service Manager是Binder机制的
上下文管理者　148
7.2.1　入口函数　148
7.2.2　打开Binder设备文件　149
7.2.3　创建设备文件　149
7.2.4　管理内存映射地址空间　154
7.2.5　发生通知　156
7.2.6　循环等待　161
7.3　内存映射　162
7.3.1　实现内存分配功能　162
7.3.2　分配物理内存　164
7.3.3　释放物理页面　166
7.3.4　分配内核缓冲区　167
7.3.5　释放内核缓冲区　168
7.3.6　查询内核缓冲区　170
第8章　init进程详解　171
8.1　init基础　171
8.2　分析入口函数　172
8.3　配置文件详解　174
8.3.1　init.rc简介　174
8.3.2　分析init.rc的过程　176
8.4　解析service　179
8.4.1　Zygote对应的service action　179
8.4.2　init组织service　180
8.4.3　函数parse_service和parse_line_service　181
8.5　字段on　184
8.5.1　Zygote对应的on action　184
8.5.2　init组织on　185
8.5.3　解析on用到的函数　186
8.6　在init控制service　186
8.6.1　启动Zygote　186
8.6.2　启动service　187
8.6.3　4种启动service的方式　191
8.7　控制属性服务　194
8.7.1　引入属性　194
8.7.2　初始化属性服务　197
8.7.3　启动属性服务　197
8.7.4　处理设置属性的请求　200
第9章　Dalvik VM的进程系统　202
9.1　Zygote（孕育）进程详解　202
9.1.1　Zygote基础　202
9.1.2　分析Zygote的启动过程　203
9.2　System进程详解　216
9.2.1　启动System进程前的准备
工作　216
9.2.2　分析SystemServer　217
9.2.3　分析EntropyService　220
9.2.4　分析DropBoxManagerService　222
9.2.5　分析DiskStatsService　227
9.2.6　分析DeviceStorageManager Service　231
9.2.7　分析SamplingProfilerService　233
9.2.8　分析ClipboardService　241
9.3　应用程序进程详解　247
9.3.1　创建应用程序　247
9.3.2　启动线程池　256
9.3.3　创建信息循环　257
第10章　Dalvik VM运作流程详解　259
10.1　Dalvik VM相关的可执行程序　259
10.1.1　dalvikvm、dvz和app_process简介　259
10.1.2　对比app_process和dalvikvm的执行过程　260
10.2　初始化Dalvik虚拟机　262
10.2.1　开始虚拟机的准备工作　262
10.2.2　初始化跟踪显示系统　262
10.2.3　初始化垃圾回收器　263
10.2.4　初始化线程列表和主线程环境参数　263
10.2.5　分配内部操作方法的表格内存　264
10.2.6　初始化虚拟机的指令码相关的内容　264
10.2.7　分配指令寄存器状态的内存　264
10.2.8　分配指令寄存器状态的内存和*基本用的Java库　265
10.2.9　初始化使用的Java类库线程类　266
10.2.10　初始化虚拟机使用的异常Java类库　267
10.2.11　初始化其他对象　268
10.3　启动Zygote　276
10.3.1　在init.rc中配置Zygote启动参数　276
10.3.2　启动Socket服务端口　276
10.3.3　加载preload-classes　277
10.3.4　加载preload-resources　277
10.3.5　使用folk启动新进程　278
10.4　启动SystemServer进程　278
10.4.1　启动各种系统服务线程　279
10.4.2　启动**个Activity　280
10.5　加载class类文件　281
10.5.1　DexFile在内存中的映射　281
10.5.2　ClassObject—Class在加载后的表现形式　283
10.5.3　加载Class并生成相应ClassObject的函数　283
10.5.4　加载基本类库文件　284
10.5.5　加载用户类文件　284
第11章　DEX文件详解　285
11.1　DEX文件介绍　285
11.2　DEX文件的格式　285
11.2.1　map_list　286
11.2.2　string_id_item　288
11.2.3　type_id_item　291
11.2.4　proto_id_item　292
11.2.5　ield_id_item　293
11.2.6　method_id_item　293
11.2.7　class_def_item　294
11.3　DEX文件结构　297
11.3.1　文件头（File Header）　297
11.3.2　魔数字段　298
11.3.3　检验码字段　298
11.3.4　SHA-1签名字段　300
11.3.5　map_off字段　300
11.3.6　string_ids_size和off字段　301
11.4　DEXFile接口详解　303
11.4.1　构造函数　303
11.4.2　公共方法　304
11.5　DEX和动态加载类机制　306
11.5.1　类加载机制　306
11.5.2　具体加载　306
11.5.3　代码加密　308
11.6　动态加载jar和DEX　309
第12章　Dvlik VM内存系统详解　310
12.1　如何分配内存　310
12.2　内存管理机制详解　312
12.3　优化Dalvik虚拟机的堆内存分配　326
第13章　Dalvik VM垃圾收集机制　328
13.1　引用计数算法　328
13.2　Mark Sweep算法　328
13.3　和垃圾收集算法有关的函数　330
13.4　垃圾回收的时机　346
13.5　调试信息　347
13.6　Dalvik VM和JVM垃圾收集机制的区别　348
第14章　Dalvik VM内存优化机制详解　350
14.1　sp和wp简介　350
14.1.1　sp基础　350
14.1.2　wp基础　351
14.2　智能指针详解　351
14.2.1　智能指针基础　352
14.2.2　轻量级指针　353
14.2.3　强指针　355
14.2.4　弱指针　365
第15章　分析Dalvik VM的启动过程　369
15.1　Dalvik VM启动流程概览　369
15.2　Dalvik VM启动过程详解　370
15.2.1　创建Dalvik VM实例　370
15.2.2　指定一系列控制选项　371
15.2.3　创建并初始化Dalvik VM实例　376
15.2.4　创建JNIEnvExt对象　378
15.2.5　设置当前进程和进程组ID　382
15.2.6　注册Android核心类的JNI方法　382
15.2.7　创建javaCreateThreadEtc钩子　385
第16章　注册Dalvik VM并创建线程　387
16.1　注册Dalvik VM的JNI方法　387
16.1.1　设置加载程序　387
16.1.2　加载so文件并验证　387
16.1.3　获取描述类　392
16.1.4　注册JNI方法　392
16.1.5　实现JNI操作　394
16.2　创建Dalvik VM进程　395
16.2.1　分析底层启动过程　395
16.2.2　创建Dalvik VM进程　395
16.2.3　初始化运行的Dalvik VM　398
16.3　创建Dalvik VM线程　399
16.3.1　检查状态值　399
16.3.2　创建线程　399
16.3.3　分析启动过程　402
16.3.4　清理线程　404
第17章　Dalvik VM异常处理详解　407
17.1　Java异常处理机制　407
17.1.1　方法调用栈　407
17.1.2　Java提供的异常处理类　409
17.2　Java VM异常处理机制详解　409
17.2.1　Java语言及虚拟机的异常处理机制　410
17.2.2　COSIX虚拟机异常处理的设计与实现　410
17.3　分析Dalvik虚拟机异常处理的源码　414
17.3.1　初始化虚拟机使用的异常Java类库　414
17.3.2　抛出一个线程异常　415
17.3.3　持续抛出进程　415
17.3.4　找出异常原因　416
17.3.5　找出异常原因　417
17.3.6　清除挂起的异常和等待初始化的异常　420
17.3.7　包装“现在等待”异常的不同例外　420
17.3.8　输出跟踪当前异常的错误信息　421
17.3.9　搜索和当前异常相匹配的方法　421
17.3.10　获取匹配的捕获块　423
17.3.11　进行堆栈跟踪　424
17.3.12　生成堆栈跟踪元素　425
17.3.13　将内容添加到堆栈跟踪日志中　426
17.3.14　将内容添加到堆栈跟踪日志中　427
17.4　常见异常的类型与原因　428
17.4.1　SQLException：操作数据库异常类　428
17.4.2　ClassCastException：数据类型转换异常　428
17.4.3　NumberFormatException：字符串转换为数字类型时抛出的异常　428
17.5　调用堆栈跟踪分析异常　429
17.5.1　解决段错误　429
17.5.2　跟踪Android Callback调用堆栈　431
第18章　JIT编译　434
18.1　JIT简介　434
18.1.1　JIT概述　434
18.1.2　Java虚拟机主要的优化技术　436
18.1.3　Dalvik中JIT的实现　436
18.2　Dalvik VM对JIT的支持　436
18.3　汇编代码和改动　438
18.3.1　汇编部分代码　438
18.3.2　对C文件的改动　438
18.4　Dalvik VM中的JIT源码　439
18.4.1　入口文件　439
18.4.2　核心函数　447
18.4.3　编译文件　450
18.4.4　BasicBlock处理　458
18.4.5　内存初始化　459
18.4.6　对JIT源码的总结　462
第19章　Dalvik VM内存优化　463
19.1　Android内存优化的作用　463
19.2　查看Android内存和CPU使用情况　464
19.2.1　利用Android API函数查看　464
19.2.2　直接对Android文件进行解析查询　464
19.2.3　通过Runtime类实现　465
19.2.4　使用DDMS工具获取　465
19.2.5　其他方法　469
19.3　Android的内存泄露　472
19.3.1　什么是内存泄漏　472
19.3.2　为什么会发生内存泄露　473
19.3.3　shallow size、retained size　474
19.3.4　查看Android内存泄露的工具——MAT　475
19.3.5　查看Android内存泄露的方法　478
19.3.6　Android（Java）中常见的容易引起内存泄漏的不良代码　480
19.4　常见的引起内存泄露的坏习惯　480
19.4.1　查询数据库时忘记关闭游标　481
19.4.2　构造Adapter时不习惯使用缓存的convertView　481
19.4.3　没有及时释放对象的引用　482
19.4.4　不在使用Bitmap对象时调用recycle()释放内存　482
19.5　解决内存泄露实践　483
19.5.1　使用MAT根据heap dump分析Java代码内存泄漏的根源　483
19.5.2　演练Android中内存泄露代码优化及检测　489
第20章　Dalvik VM性能优化　491
20.1　加载APK DEX文件优化　491
20.1.1　APK文件介绍　492
20.1.2　DEX文件优化　493
20.1.3　使用类动态加载技术实现加密优化　493
20.2　SD卡优化　496
20.3　虚拟机优化详解　497
20.3.1　平台优化—ARM的流水线技术　497
20.3.2　Android对C库优化　501
20.3.3　优化创建的进程　504
20.3.4　渲染优化　504
第21章　分析ART的启动过程　508
21.1　运行环境的转换　508
21.2　运行 app_process 进程　509
21.3　准备启动　512
21.4　创建运行实例　518
21.5　注册本地JNI函数　519
21.6　启动守护进程　520
21.7　解析参数　521
21.8　初始化类、方法和域　528
第22章　执行ART主程序　534
22.1　进入main主函数　534
22.2　查找目标类　535
22.2.1　函数LookupClass()　535
22.2.2　函数DefineClass()　537
22.2.3　函数InsertClass()　540
22.2.4　函数LinkClass()　541
22.3　类操作　543
22.4　实现托管操作　544
第23章　安装APK应用程序　549
23.1　PackageManagerService概述　549

23.2　主函数main　549
23.3　调用初始化函数　550
23.4　创建PackageManagerService服务　553
23.5　扫描并解析　554
23.6　保存解析信息　570
第24章　ART环境安装APK应用程序　572
24.1　Android安装APK概述　572
24.2　启动时安装　572
24.3　ART安装　581
24.4　实现dex2oat转换　586
24.4.1　参数解析　586
24.4.2　创建 OAT文件指针　588
24.4.3　dex2oat准备工作　588
24.4.4　提取classes.dex文件　589
24.4.5　创建OAT文件　594
24.5　APK文件的转换　595信息
