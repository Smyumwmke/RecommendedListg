深入浅出RxJS PDF下载 程墨 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711159664
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711159664
<p>书名:深入浅出RxJS</p><p>作者:程墨</p><p>页数:398</p><p>定价:¥89.0</p><p>出版社:机械工业出版社</p><p>出版日期:2018-05-01</p><p>ISBN:9787111596646</p><p><h2>本书特色</h2></p>[<p>
随着互联网行业的飞速发展，Web开发者面临的挑战也越来越大，伴随着功能的增多，Web应用的复杂度也快速膨胀。对于Web应用，*复杂的问题就是异步操作的处理， 无论用户操作、AJAX请求、动画、WebSocket推送都涉及到异步操作，传统的异步处理方法越来越不适应复杂应用的需要，RxJS的产生，就是为了解决日益复杂的前端异步处理问题。RxJS是一门进入门槛比较高的技术，本书的目的就是降低学习成本，由浅入深地介绍RxJS，逐步解析这门技术的各个方面，让读者能够以一个平缓的学习曲线来掌握这一潜力无限的技术。<br/>主要内容包括：·函数响应式编程·数据流的工作原理·RxJS操作符的创建方法·RxJS所有操作符的详细分类介绍·多播的应用·Scheduler的应用·RxJS的调试和测试方法·React、Redux和RxJS的组合使用方法·RxJS开发游戏的实践随着互联网行业的飞速发展，Web开发者面临的挑战也越来越大，伴随着功能的增多，Web应用的复杂度也快速膨胀。对于Web应用，*复杂的问题就是异步操作的处理， 无论用户操作、AJAX请求、动画、WebSocket推送都涉及到异步操作，传统的异步处理方法越来越不适应复杂应用的需要，RxJS的产生，就是为了解决日益复杂的前端异步处理问题。RxJS是一门进入门槛比较高的技术，本书的目的就是降低学习成本，由浅入深地介绍RxJS，逐步解析这门技术的各个方面，让读者能够以一个平缓的学习曲线来掌握这一潜力无限的技术。<br/>主要内容包括：·函数响应式编程·数据流的工作原理·RxJS操作符的创建方法·RxJS所有操作符的详细分类介绍·多播的应用·Scheduler的应用·RxJS的调试和测试方法·React、Redux和RxJS的组合使用方法·RxJS开发游戏的实践
本书系统讲解RxJS响应式编程的技术原理与应用。第1章剖析函数响应式编程的基本概念，通过简单RxJS代码引入函数响应式编程，并与传统编程方式对比，解释这种编程范式的优势，以及这种范式形成的历史。第2章介绍学习RxJS必须掌握的基本概念，包括数据流、操作符和观察者模式。第3~9章介绍RxJS的各种操作符，以及如何选择恰当的操作符来完成不同的任务。第10章介绍RxJS如何实现多播的方式。第11章介绍实现调度Scheduler的作用、原理与使用。第12章介绍如何调试和测试RxJS相关代码，写出高可测试性代码。第13章介绍如何在React应用中使用RxJS，提高代码质量。第14章介绍Redux与RxJS的组合应用，发挥两者的共同优势。第15章介绍一个综合案例，用RxJS实现网页游戏Breakout，并剖析RxJS如何实现动画和绘图。
                                        </p>]<p><h2>内容简介</h2></p>[<p>软件开发中有什么老问题？技术发展迅速，用户的需求增加更快，软件的代码库也会随需求增长快速膨胀。<br/>在这种情况下，如何保证代码质量？如何控制代码的复杂度？如何维持代码的可维护性？这些就成了软件开发的大问题。业界的同仁们为了解决这些老问题做了各种努力，函数式编程和响应式编程就是在实践中被证明行之有效的两种方法。<br/>RxJS兼具函数式和响应式两种编程方式的特点，RxJS擅长处理异步操作，因为它对数据采用“推”的处理方式，当一个数据产生的时候，被推送给对应的处理函数，这个处理函数不用关心数据是同步产生的还是异步产生的，这样就把开发者从命令式异步处理的枷锁中解放了出来。<br/>本书由浅入深地讲解RxJS，不仅介绍所有操作符的功能，而且讲解实际应用与利弊，是提升开发内功的好教程。 </p>]<p><h2>作者简介</h2></p>[<p>程墨  架构师，曾任职于摩托罗拉、雅虎和微软，云鸟配送平台联合创始人，目前服务于美国视频服务公司Hulu。</p>]<p><h2>目录</h2></p>
    目录  Contents前言第1章　函数响应式编程11.1　一个简单的RxJS例子11.2　函数式编程51.2.1　什么是函数式编程51.2.2　为什么函数式编程*近才崛起111.2.3　函数式编程和面向对象编程的比较131.3　响应式编程141.4　Reactive Extension151.5　RxJS是否是函数响应式编程161.6　函数响应式编程的优势171.7　本章小结18第2章　RxJS入门192.1　RxJS的版本和运行环境192.2　Observable和Observer242.2.1　观察者模式242.2.2　迭代器模式252.2.3　创造Observable262.2.4　跨越时间的Observable282.2.5　永无止境的Observable292.2.6　Observable的完结302.2.7　Observable的出错处理312.2.8　Observer的简单形式322.3　退订Observable332.4　Hot Observable和Cold Observable352.5　操作符简介372.6　弹珠图392.7　本章小结41第3章　操作符基础423.1　为什么要有操作符423.2　操作符的分类443.2.1　功能分类453.2.2　静态和实例分类463.3　如何实现操作符493.3.1　操作符函数的实现493.3.2　关联Observable533.3.3　改进的操作符定义553.3.4　lettable/pipeable 操作符603.4　本章小结68第4章　创建数据流694.1　创建类操作符704.2　创建同步数据流704.2.1　create：毫无神奇之处714.2.2　of：列举数据714.2.3　range：指定范围734.2.4　generate：循环创建744.2.5　repeat：重复数据的数据流754.2.6　三个极简的操作符：empty、never和throw784.3　创建异步数据的Observable对象804.3.1　interval和timer：定时产生数据804.3.2　from:可把一切转化为Observable824.3.3　fromPromise：异步处理的交接844.3.4　fromEvent854.3.5　fromEventPattern874.3.6　ajax884.3.7　repeatWhen894.3.8　defer914.4　本章小结92第5章　合并数据流935.1　合并类操作符945.1.1　concat：首尾相连945.1.2　merge：先到先得快速通过965.1.3　zip:拉链式组合995.1.4　combineLatest：合并*后一个数据1025.1.5　withLatestFrom1095.1.6　解决glitch1125.1.7　race：胜者通吃1155.1.8　startWith1155.1.9　forkJoin1175.2　高阶Observable1185.2.1　高阶Observable的意义1195.2.2　操作高阶Observable的合并类操作符1205.2.3　进化的高阶Observable处理1245.3　本章小结128第6章　辅助类操作符1296.1　数学类操作符1296.1.1　count：统计数据个数1306.1.2　max和min：*大*小值1306.1.3　reduce：规约统计1316.2　条件布尔类操作符1336.2.1　every1346.2.2　find和findIndex1356.2.3　isEmpty1376.2.4　defaultIfEmpty1386.3　本章小结138第7章　过滤数据流1397.1　过滤类操作符的模式1407.1.1　filter1417.1.2　first1427.1.3　last1447.1.4　take一族操作符1457.1.5　计时的点击计数网页程序1507.1.6　skip1517.1.7　skipWhile和skipUntil1517.2　回压控制1527.2.1　throttle和debounce1547.2.2　auditTime和audit1647.2.3　sampleTime和sample1667.2.4　根据数据序列做回压控制1687.3　其他过滤方式1717.3.1　ignoreElements1727.3.2　elementAt1727.3.3　single1737.4　本章小结173第8章　转化数据流1748.1　转化类操作符1748.2　映射数据1758.2.1　map1768.2.2　mapTo1778.2.3　pluck1788.3　缓存窗口：无损回压控制1798.3.1　windowTime和bufferTime1808.3.2　windowCount和bufferCount1838.3.3　windowWhen和bufferWhen1848.3.4　windowToggle和buffer-Toggle1858.3.5　window和buffer1868.4　高阶的map1888.4.1　concatMap1898.4.2　mergeMap1928.4.3　switchMap1938.4.4　exhaustMap1958.4.5　高阶的MapTo1958.4.6　expand1968.5　数据分组1968.6　累计数据2008.6.1　scan2008.6.2　mergeScan2018.7　本章小结203第9章　异常错误处理2049.1　异常处理不可避免2049.2　异常处理的难点2069.2.1　try/catch只支持同步运算2079.2.2　回调函数的局限2079.2.3　Promise的异常处理2099.3　RxJS的异常处理2129.3.1　catch2149.3.2　retry2169.3.3　retryWhen2179.3.4　finally2209.4　重试的本质2219.5　本章小结223第10章　多播22510.1　数据流的多播22510.2　Hot和Cold数据流差异22810.3　Subject23010.3.1　两面神Subject23010.3.2　用Subject实现多播23310.3.3　makeHot 操作符23410.3.4　Subject不能重复使用23510.3.5　Subject可以有多个上游23710.3.6　Subject的错误处理23910.4　支持多播的操作符24110.4.1　multicast24110.4.2　publish25310.4.3　share25510.5　高级多播功能25710.5.1　publishLast和Async-Subject25810.5.2　pubishReplay和Replay-Subject25910.5.3　publishBehavior和BehaviorSubject26210.6　本章小结263第11章　掌握时间的Scheduler26511.1　Schedu
