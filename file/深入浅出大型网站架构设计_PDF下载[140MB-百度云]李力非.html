深入浅出大型网站架构设计 PDF下载 李力非 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712135397
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712135397
<p>书名:深入浅出大型网站架构设计</p><p>作者:李力非</p><p>页数:256</p><p>定价:¥89.0</p><p>出版社:电子工业出版社</p><p>出版日期:2020-05-01</p><p>ISBN:9787121353970</p><p><h2>本书特色</h2></p>[<p>
为了帮助有一定编程基础的读者快速了解如何以职业标准开发一个网站，本书从架构设计的角度出发，涵盖了以高性能、高可用、高并发等多个业内标准为目标的网站设计和建设手段，并在每个方面追本溯源，从理论方法到生产实践，在力求简明易懂、适用于尽可能多的场合的前提下深入到实践中，为读者提供实用操作指南。同时，本书对所有出现的概念都作了简明扼要的解释，并对介绍的手段和方案不仅解释了如何做，也解释了来源和选择理由，使得读者在理解内容并能应用的同时，也能理解这些手段背后的思路，将来亦可脱离书本，作出属于自己的创新方案，真正做到了授人以鱼不如授人以渔。
                                        </p>]<p><h2>内容简介</h2></p>[<p>为了帮助有一定编程基础的读者快速了解如何以职业标准开发一个网站，本书从架构设计的角度出发，涵盖了以高性能、高可用、高并发等多个业内标准为目标的网站设计和建设手段，并在每个方面追本溯源，从理论方法到生产实践，在力求简明易懂、适用于尽可能多的场合的前提下深入到实践中，为读者提供实用操作指南。同时，本书对所有出现的概念都作了简明扼要的解释，并对介绍的手段和方案不仅解释了如何做，也解释了来源和选择理由，使得读者在理解内容并能应用的同时，也能理解这些手段背后的思路，将来亦可脱离书本，作出属于自己的创新方案，真正做到了授人以鱼不如授人以渔。</p>]<p><h2>作者简介</h2></p>[<p>李力非，2014年起进入互联网软件开发行业，并于2015年加入亚马逊公司，从事软件开发和设计至今，对后端服务器开发、移动端开发和前端网页开发均有涉猎，先后参与亚马逊购物网站移动APP、Alexa智能家居的自动化控制系统和亚马逊事务类通知系统的软件开发和设计，领导并参与了多个大型项目。熟悉如何结合设计原则和方法设计超大流量的网络服务，并擅长根据实际情况和限制，灵活调整系统架构。其中参与设计与开发的Alexa智能家居自动化控制系统的每日用户使用人次超过2500万并持续增长，牢牢占据同类产品的市场占有率第一；参与开发的亚马逊事务类通知系统每日吞吐量达上亿。</p>]<p><h2>目录</h2></p>
    目录 第1 章 网站架构概述 1 1.1 网站的基本组件 1 1.2 网站业务规模增长带来的问题 2 1.3 大型网站架构设计的目标和原则 4 1.3.1 高性能 4 1.3.2 高可用 5 1.3.3 伸缩性 6 1.3.4 扩展性 7 第2 章 大型网站架构设计的流程 9 2.1 需求分析 9 2.1.1 需求驱动的重要性 9 2.1.2 如何根据需求制定系统目标 10 2.2 方案设计 11 2.2.1 与架构设计原则相结合 11 2.2.2 设计多套备选方案 12 2.3 方案评估 13 第3 章 数据库的选择 15 3.1 关系数据库 15 3.1.1 什么是关系数据库 16 3.1.2 关系数据库的优势和应用场景 17 3.2 非关系数据库 18 3.2.1 什么是非关系数据库 18 3.2.2 非关系数据库的优势和应用场景 19 3.3 常见的关系数据库产品 20 3.3.1 MySQL 20 3.3.2 MS SQL Server 21 3.3.3 Oracle 22 3.4 常见的非关系数据库产品 22 3.4.1 MongoDB 23 3.4.2 DynamoDB 23 3.5 云数据库 23 第4 章 数据库优化：分库分表 25 4.1 什么是分库分表 25 4.1.1 分库 25 4.1.2 分表 26 4.2 为什么要进行分库分表 27 4.2.1 吞吐量 27 4.2.2 索引 27 4.2.3 备份 28 4.2.4 其他风险 28 4.3 实现分库分表 28 4.3.1 垂直分库分表 29 4.3.2 水平分库分表 30 4.4 分库分表带来的问题 32 4.4.1 全局唯一ID 32 4.4.2 关系数据库的部分操作 33 4.4.3 事务支持 33 第5 章 数据库优化：读写分离 34 5.1 什么是读写分离 34 5.2 为什么要使用读写分离 35 5.2.1 何时需要使用读写分离 35 5.2.2 读写分离的好处 36 5.3 实现读写分离 37 5.3.1 中间件实现 37 5.3.2 应用层实现 38 5.4 读写分离带来的问题 39 5.4.1 副本的实时性 39 5.4.2 副本实时性的解决方案 39 5.4.3 成本问题 40 第6 章 缓存 41 6.1 什么是缓存 41 6.2 缓存策略 42 6.2.1 LFU 缓存策略 42 6.2.2 LRU 缓存策略 43 6.2.3 缓存策略的优劣 43 6.3 缓存命中率 44 6.4 缓存的类型 44 6.4.1 客户端缓存 44 6.4.2 CDN 缓存 45 6.4.3 应用缓存 45 6.4.4 基于分布式集群的缓存 45 6.5 分布式缓存 46 6.5.1 分布式缓存的应用场景 46 6.5.2 分布式缓存的架构设计 47 6.6 缓存的问题 47 6.6.1 缓存过热 47 6.6.2 缓存穿透 48 6.6.3 缓存雪崩 48 6.7 常见的缓存系统 49 6.7.1 MemCached 49 6.7.2 Redis 49 第7 章 动静分离 50 7.1 动静分离 50 7.1.1 动态数据和静态数据 50 7.1.2 动静分离的概念 52 7.1.3 动静分离的作用 53 7.2 拆分动态数据和静态数据 55 7.2.1 识别动态数据和静态数据 55 7.2.2 改造数据 56 7.2.3 改造数据要注意的问题 60 7.3 动静分离的架构改造 62 7.3.1 动静分离的缓存架构 62 7.3.2 浏览器缓存 63 7.3.3 CDN 缓存 64 7.3.4 Web 服务器缓存 65 7.3.5 分布式缓存 65 7.3.6 页面组装 66 第8 章 负载均衡 67 8.1 什么是负载均衡 67 8.1.1 负载均衡的概念 67 8.1.2 负载均衡的类型 69 8.1.3 有负载均衡的网站架构 69 8.1.4 反向代理 70 8.2 DNS 负载均衡 72 8.2.1 DNS 73 8.2.2 A 记录 73 8.2.3 CName 73 8.2.4 配置DNS 负载均衡 74 8.2.5 DNS 负载均衡的优缺点 75 8.3 硬件负载均衡 76 8.4 软件负载均衡：LVS 77 8.4.1 LVS 架构 77 8.4.2 LVS 的负载均衡方式 78 8.4.3 LVS 的负载均衡策略 80 8.4.4 LVS 的调整升级 81 8.4.5 LVS 的优缺点 81 8.5 软件负载均衡：Nginx 82 8.5.1 Nginx 架构 82 8.5.2 Nginx 的工作原理 83 8.5.3 Nginx 的负载均衡策略 84 8.5.4 Nginx 的错误重试 85 8.5.5 Nginx 的调整升级 85 8.5.6 Nginx 的主要特点 86 8.5.7 Nginx 配置实战 86 8.6 负载均衡的实践流程 89 8.6.1 回顾流量基本概念 90 8.6.2 实践流程 90 第9 章 异步和非阻塞 93 9.1 异步及其相关概念 93 9.1.1 同步和异步 94 9.1.2 阻塞和非阻塞 94 9.1.3 多线程 96 9.2 异步和非阻塞的作用 97 9.2.1 异步和非阻塞的应用场景 97 9.2.2 异步和非阻塞的架构 102 9.2.3 异步的优势 103 9.3 实战：以Java 为例 105 9.3.1 Runnable 105 9.3.2 Callable 106 9.3.3 Future 106 9.3.4 Executor 和ExecutorService 108 9.3.5 改造同步且阻塞的Java 代码 108 9.4 异步和非阻塞带来的问题 112 9.4.1 API 定义 113 9.4.2 线程池的扩容 113 第10 章 队列 116 10.1 队列及其相关概念 116 10.1.1 队列 116 10.1.2 生产/消费、发布/订阅与主题 117 10.2 队列与网站的整合 119 10.2.1 发布者 119 10.2.2 订阅者 120 10.2.3 订阅者：推送模式 120 10.2.4 订阅者：拉取/轮询模式 122 10.3 队列的应用 123 10.3.1 流量控制 123 10.3.2 服务解耦 126 10.4 队列存在的问题与解决方案 128 10.4.1 消息积压 128 10.4.2 消息的可靠传递 130 10.4.3 消息重复 133 10.5 常见的队列产品和系统 134 10.5.1 RabbitMQ 134 10.5.2 ActiveMQ 135 10.5.3 RocketMQ 135 10.5.4 Kafka 136 10.5.5 AWS SQS 和SNS 136 第11 章 高可用 137 11.1 CAP 原理 137 11.1.1 什么是CAP 原理 137 11.1.2 CAP 原理与网站服务 138 11.2 服务可用性的标准 141 11.3 冗余和隔离 142 11.3.1 扩容中的冗余 142 11.3.2 广义的冗余 142 11.3.3 隔离 142 第12 章 异地多活 144 12.1 异地多活的基本概念 144 12.1.1 基本概念 144 12.1.2 作用 145 12.1.3 应用场景 145 12.1.4 异地多活和负载均衡 147 12.2 异地多活的类型 147 12.2.1 同城异地多活 147 12.2.2 跨城市异地多活 148 12.2.3 跨地区异地多活 149 12.3 如何进行异地多活改造 149 12.3.1 业务分类 149 12.3.2 数据分类 150 12.3.3 数据同步 151 12.3.4 异地多活的数据同步提升方案 153 第13 章 服务降级 156 13.1 服务降级的基本概念 156 13.1.1 什么是服务降级 156 13.1.2 单点故障 158 13.2 微服务与服务拆分 160 13.2.1 什么是微服务 160 13.2.2 流量模式 161 13.2.3 如何拆分服务 162 13.3 系统分级 165 13.3.1 分析系统流程图 165 13.3.2 一级系统 166 第14 章 限流 168 14.1 限流的基本概念 168 14.1.1 什么是限流 168 14.1.2 为什么需要限流 169 14.1.3 限流的几种标准 171 14.1.4 限流的几种思路 172 14.2 限流算法 176 14.2.1 令牌桶算法与漏桶算法 176 14.2.2 时间窗口算法 179 14.2.3 队列法 182 14.3 服务限流需要考虑的问题 183 14.3.1 性能和准确性 183 14.3.2 如何进一步提升 184 14.4 实战：使用Nginx 限流 186 第15 章 下游错误处理 191 15.1 超时机制 191 15.2 错误分类 192 15.2.1 如何分类错误 192 15.2.2 早期失败 194 15.2.3 默认值的作用 194 15.3 错误重试 195 15.3.1 错误重试的条件 196 15.3.2 错误重试带来的问题 196 第16 章 测试 198 16.1 测试的类型 198 16.1.1 一般功能测试 198 16.1.2 黑盒和白盒测试 200 16.1.3 不同程度的功能测试 202 16.1.4 非功能的测试 204 16.2 测试用例的设计 206 16.2.1 模拟实际环境 206 16.2.2 包含错误情况 207 16.2.3 保证用例多样性 209 16.2.4 验证系统间的连接性 212 16.3 功能测试详解 213 16.3.1 单元测试 213 16.3.2 集成测试 217 16.3.3 端到端测试 219 第17 章 1
