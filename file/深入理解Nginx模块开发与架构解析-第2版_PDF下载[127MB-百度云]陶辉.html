深入理解Nginx模块开发与架构解析-第2版 PDF下载 陶辉 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711152625
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711152625
<p>书名:深入理解Nginx模块开发与架构解析-第2版</p><p>作者:陶辉</p><p>页数:624</p><p>定价:¥99.0</p><p>出版社:机械工业出版社</p><p>出版日期:2016-02-01</p><p>ISBN:9787111526254</p><p><h2>本书特色</h2></p>[<p>

	本书包括四大部分：nginx能帮我做什么；如何编写一个定制的httpmodule；深入nginx；实战。**部分针对初级读者，介绍nginx关于获取编译运行的基本知识。第二部分针对中级读者，以一个例子为主线，告诉读者如何开发一个http模块，这部分读者不需要深入了解nginx的细节，只需要知道如何实现一个基本的http模块。第三部分针对高级读者，这是本书的重点，彻底解析nginx架构，深入探讨nginx各种设计的目的与意义，并对第二部分使用到的一些特性进行代码设计实现上的探索。读者读完本部分，会对整个nginx架构有清晰的认识，可以编写各种模块（不局限于http模块）插入到nginx中，从而定制自己的nginx。第四部分针对中高级读者，以tengine的开源模块为例，帮助读者从实战角度理解第二、三部分描述的内容。


	 

                                        </p>]<p><h2>目录</h2></p>
    	contents?目　　录前　言**部分　nginx能帮我们做什么第1章　研究nginx前的准备工作  21.1　nginx是什么  21.2　为什么选择nginx  51.3　准备工作  71.3.1　linux操作系统  71.3.2　使用nginx的**软件  71.3.3　磁盘目录  81.3.4　linux内核参数的优化  91.3.5　获取nginx源码  101.4　编译安装nginx  111.5　conf?igure详解  111.5.1　conf?igure的命令参数  111.5.2　conf?igure执行流程  181.5.3　conf?igure生成的文件  211.6　nginx的命令行控制  231.7　小结  27第2章　nginx的配置  282.1　运行中的nginx进程间的关系  282.2　nginx配置的通用语法  312.2.1　块配置项  312.2.2　配置项的语法格式 322.2.3　配置项的注释  332.2.4　配置项的单位  332.2.5　在配置中使用变量 332.3　nginx服务的基本配置  342.3.1　用于调试进程和定位问题的配置项 342.3.2　正常运行的配置项 362.3.3　优化性能的配置项 372.3.4　事件类配置项  392.4　用http核心模块配置一个静态web服务器  402.4.1　虚拟主机与请求的分发 412.4.2　文件路径的定义  452.4.3　内存及磁盘资源的分配 472.4.4　网络连接的设置  492.4.5　mime类型的设置  522.4.6　对客户端请求的限制 532.4.7　文件操作的优化  542.4.8　对客户端请求的特殊处理 562.4.9　ngx_http_core_module模块提供的变量  572.5　用http proxy module配置一个反向代理服务器  592.5.1　负载均衡的基本配置 612.5.2　反向代理的基本配置 632.6　小结  66第二部分　如何编写http模块第3章　开发一个简单的http模块  683.1　如何调用http模块  683.2　准备工作  703.2.1　整型的封装  713.2.2　ngx_str_t数据结构  713.2.3　ngx_list_t数据结构  713.2.4　ngx_table_elt_t数据结构  753.2.5　ngx_buf_t数据结构  753.2.6　ngx_chain_t数据结构  773.3　如何将自己的http模块编译进nginx  773.3.1　conf?ig文件的写法  773.3.2　利用conf?igure脚本将定制的模块加入到nginx中  783.3.3　直接修改makef?ile文件  813.4　http模块的数据结构  823.5　定义自己的http模块  863.6　处理用户请求  893.6.1　处理方法的返回值 893.6.2　获取uri和参数  923.6.3　获取http头部  943.6.4　获取http包体  973.7　发送响应  993.7.1　发送http头部  993.7.2　将内存中的字符串作为包体发送 1013.7.3　经典的“hello world”示例  1023.8　将磁盘文件作为包体发送 1033.8.1　如何发送磁盘中的文件 1043.8.2　清理文件句柄  1063.8.3　支持用户多线程下载和断点续传 1073.9　用c++语言编写http模块  1083.9.1　编译方式的修改  1083.9.2　程序中的符号转换 1093.10　小结  110第4章　配置、error日志和请求上下文  1114.1　http配置项的使用场景  1114.2　怎样使用http配置  1134.2.1　分配用于保存配置参数的数据结构 1134.2.2　设定配置项的解析方式 1154.2.3　使用14种预设方法解析配置项  1214.2.4　自定义配置项处理方法 1314.2.5　合并配置项  1334.3　http配置模型  1354.3.1　解析http配置的流程  1364.3.2　http配置模型的内存布局  1394.3.3　如何合并配置项 1424.3.4　预设配置项处理方法的工作原理 1444.4　error日志的用法  1454.5　请求的上下文  1494.5.1　上下文与全异步web服务器的关系  1494.5.2　如何使用http上下文  1514.5.3　http框架如何维护上下文结构  1524.6　小结  153第5章　访问第三方服务  1545.1　upstream的使用方式  1555.1.1　ngx_http_upstream_t结构体  1585.1.2　设置upstream的限制性参数  1595.1.3　设置需要访问的第三方服务器地址 1605.1.4　设置回调方法  1615.1.5　如何启动upstream机制  1615.2　回调方法的执行场景 1625.2.1　create_request回调方法  1625.2.2　reinit_request回调方法  1645.2.3　f?inalize_request回调方法  1655.2.4　process_header回调方法  1655.2.5　rewrite_redirect回调方法  1675.2.6　input_f?ilter_init与input_f?ilter回调方法  1675.3　使用upstream的示例  1685.3.1　upstream的各种配置参数  1685.3.2　请求上下文  1705.3.3　在create_request方法中构造请求  1705.3.4　在process_header方法中解析包头  1715.3.5　在f?inalize_request方法中释放资源  1755.3.6　在ngx_http_mytest_handler方法中启动upstream  1755.4　subrequest的使用方式  1775.4.1　配置子请求的处理方式 1775.4.2　实现子请求处理完毕时的回调方法 1785.4.3　处理父请求被重新激活后的回调方法 1795.4.4　启动subrequest子请求  1795.5　subrequest执行过程中的主要场景  1805.5.1　如何启动subrequest 1805.5.2　如何转发多个子请求的响应包体 1825.5.3　子请求如何激活父请求 1855.6　subrequest使用的例子  1875.6.1　配置文件中子请求的设置 1875.6.2　请求上下文  1885.6.3　子请求结束时的处理方法 1885.6.4　父请求的回调方法 1895.6.5　启动subrequest 1905.7　小结  191第6章　开发一个简单的http过滤模块  1926.1　过滤模块的意义  1926.2　过滤模块的调用顺序 1936.2.1　过滤链表是如何构成的 1946.2.2　过滤链表的顺序 1966.2.3　官方默认http过滤模块的功能简介  1976.3　http过滤模块的开发步骤  1986.4　http过滤模块的简单例子  2006.4.1　如何编写conf?ig文件  2016.4.2　配置项和上下文 2016.4.3　定义http过滤模块  2036.4.4　初始化http过滤模块  2046.4.5　处理请求中的http头部  2046.4.6　处理请求中的http包体  2066.5　小结  206第7章　nginx提供的高级数据结构  2077.1　nginx提供的高级数据结构概述  2077.2　ngx_queue_t双向链表  2097.2.1　为什么设计ngx_queue_t双向链表  2097.2.2　双向链表的使用方法 2097.2.3　使用双向链表排序的例子 2127.2.4　双向链表是如何实现的 2137.3　ngx_array_t动态数组  2157.3.1　为什么设计ngx_array_t动态数组  2157.3.2　动态数组的使用方法 2157.3.3　 使用动态数组的例子 2177.3.4　动态数组的扩容方式 2187.4　ngx_list_t单向链表  2197.5　ngx_rbtree_t红黑树  2197.5.1　为什么设计ngx_rbtree_t红黑树  2197.5.2　红黑树的特性  2207.5.3　红黑树的使用方法 2227.5.4　使用红黑树的简单例子 2257.5.5　如何自定义添加成员方法 2267.6　ngx_radix_tree_t基数树  2287.6.1　ngx_radix_tree_t基数树的原理  2287.6.2　基数树的使用方法 2307.6.3　使用基数树的例子 2317.7　支持通配符的散列表 2327.7.1　ngx_hash_t基本散列表  2327.7.2　支持通配符的散列表 2357.7.3　带通配符散列表的使用例子 2417.8　小结  245第三部分　深入nginx第8章　nginx基础架构  2488.1　web服务器设计中的关键约束  2498.2　nginx的架构设计  2518.2.1　优秀的模块化设计 2518.2.2　事件驱动架构  2548.2.3　请求的多阶段异步处理 2568.2.4　管理进程、多工作进程设计 2598.2.5　平台无关的代码实现 2598.2.6　内存池的设计  2598.2.7　使用统一管道过滤器模式的http过滤模块  2608.2.8　其他一些用户模块 2608.3　nginx框架中的核心结构体ngx_cycle_t  2608.3.1　ngx_listening_t结构体  2618.3.2　ngx_cycle_t结构体  2628.3.3　ngx_cycle_t支持的方法  2648.4　nginx启动时框架的处理流程  2668.5　worker进程是如何工作的  2698.6　master进程是如何工作的  2718.7　ngx_pool_t内存池  2768.8　小结  284第9章　事件模块  2859.1　事件处理框架概述  2869.2　nginx事件的定义  2889.3　nginx连接的定义  2919.3.1　被动连接  2929.3.2　主动连接  2959.3.3　ngx_connection_t连接池  2969.4　ngx_events_module核心模块  2979.4.1　如何管理所有事件模块的配置项 2999.4.2　管理事件模块  3009.5　ngx_event_core_module事件模块  3029.6　epoll事件驱动模块  3089.6.1　epoll的原理和用法  3089.6.2　如何使用epoll 3109.6.3　ngx_epoll_module模块的实现  3129.7　定时器事件  3209.7.1　缓存时间的管理 3209.7.2　缓存时间的精度 3239.7.3　定时器的实现  3239.8　事件驱动框架的处理流程 3249.8.1　如何建立新连接 3259.8.2　如何解决“惊群”问题 3279.8.3　如何实现负载均衡 3299.8.4　post事件队列  3309.8.5　ngx_process_events_and_timers流程  3319.9　文件的异步i/o  3349.9.1　linux内核提供的文件异步i/o  3359.9.2　ngx_epoll_module模块中实现的针对文件的异步i/o  3379.10　tcp协议与nginx  3429.11　小结  347第10章　http框架的初始化  34810.1　http框架概述  34910.2　管理http模块的配置项  35210.2.1　管理main级别下的配置项  35310.2.2　管理server级别下的配置项  35510.2.3　管理location级别下的配置项  35810.2.4　不同级别配置项的合并 36410.3　监听端口的管理  36710.4　server的快速检索  37010.5　location的快速检索  37010.6　http请求的11个处理阶段  37210.6.1　http处理阶段的普适规则  37410.6.2　ngx_http_post_read_phase阶段  37510.6.3　ngx_http_server_rewrite_phase阶段  37810.6.4　ngx_http_find_config_phase阶段  37810.6.5　ngx_http_rewrite_phase阶段  37810.6.6　ngx_http_post_rewrite_phase阶段  37910.6.7　ngx_http_preaccess_phase阶段  37910.6.8　ngx_http_access_phase阶段  37910.6.9　ngx_http_post_access_phase阶段  38010.6.10　ngx_http_try_files_phase阶段  38010.6.11　ngx_http_content_phase阶段  38010.6.12　ngx_http_log_phase阶段  38210.7　http框架的初始化流程  38210.8　小结  384第11章　http框架的执行流程  38511.1　http框架执行流程概述  38611.2　新连接建立时的行为 38711.3　**次可读事件的处理 38811.4　接收http请求行  39411.5　接收http头部  39811.6　处理http请求  40011.6.1　ngx_http_core_generic_phase  40611.6.2　ngx_http_core_rewrite_phase  40811.6.3　ngx_http_core_access_phase  40911.6.4　ngx_http_core_content_phase  41211.7　subrequest与post请求  41511.8　处理http包体  41711.8.1　接收包体  41911.8.2　放弃接收包体 42511.9　发送http响应  42911.9.1　ngx_http_send_header  43011.9.2　ngx_http_output_f?ilter  43211.9.3　ngx_http_writer 43511.10　结束http请求  43711.10.1　ngx_http_close_connection  43811.10.2　ngx_http_free_request  43911.10.3　ngx_http_close_request  44011.10.4　ngx_http_f?inalize_connection  44111.10.5　ngx_http_terminate_request  44311.10.6　ngx_http_f?inalize_request  44311.11　小结  446第12章　upstream机制的设计与实现  44712.1　upstream机制概述  44812.1.1　设计目的  44812.1.2　ngx_http_upstream_t数据结构的意义  45012.1.3　ngx_http_upstream_conf_t配置结构体  45312.2　启动upstream 45512.3　与上游服务器建立连接 45712.4　发送请求到上游服务器 46012.5　接收上游服务器的响应头部 46312.5.1　应用层协议的两段划分方式 46312.5.2　处理包体的3种方式  46412.5.3　接收响应头部的流程 46512.6　不转发响应时的处理流程 46912.6.1　input_f?ilter方法的设计  46912.6.2　默认的input_f?ilter方法  47012.6.3　接收包体的流程 47212.7　以下游网速优先来转发响应 47312.7.1　转发响应的包头 47412.7.2　转发响应的包体 47712.8　以上游网速优先来转发响应 48112.8.1　ngx_event_pipe_t结构体的意义  48112.8.2　转发响应的包头 48512.8.3　转发响应的包体 48712.8.4　ngx_event_pipe_read_upstream方法  48912.8.5　ngx_event_pipe_write_to_downstream方法  49412.9　结束upstream请求  49612.10　小结  499第13章　邮件代理模块  50013.1　邮件代理服务器的功能 50013.2　邮件模块的处理框架 50313.2.1　一个请求的8个独立处理阶段  50313.2.2　邮件类模块的定义 50413.2.3　邮件框架的初始化 50613.3　初始化请求  50613.3.1　描述邮件请求的ngx_mail_session_t结构体  50613.3.2　初始化邮件请求的流程 50913.4　接收并解析客户端请求 50913.5　邮件认证  51013.5.1　ngx_mail_auth_http_ctx_t结构体  51013.5.2　与认证服务器建立连接 51113.5.3　发送请求到认证服务器 51313.5.4　接收并解析响应 51413.6　与上游邮件服务器间的认证交互 51413.6.1　ngx_mail_proxy_ctx_t结构体  51613.6.2　向上游邮件服务器发起连接 51613.6.3　与邮件服务器认证交互的过程 51813.7　透传上游邮件服务器与客户端间的流 52013.8　小结  524第14章　进程间的通信机制  52514.1　概述  52514.2　共享内存  52614.3　原子操作  53014.3.1　不支持原子库下的原子操作 53014.3.2　x86架构下的原子操作  53114.3.3　自旋锁  53314.4　nginx频道  53514.5　信号  53814.6　信号量  54014.7　文件锁  54114.8　互斥锁  54414.8.1　文件锁实现的ngx_shmtx_t锁  54614.8.2　原子变量实现的ngx_shmtx_t锁  54814.9　小结  553第15章　变量  55415.1　使用内部变量开发模块 55515.1.1　定义模块  55615.1.2　定义http模块加载方式  55715.1.3　解析配置中的变量 55815.1.4　处理请求  56015.2　内部变量工作原理 56115.2.1　何时定义变量 56115.2.2　相关数据结构详述 56415.2.3　定义变量的方法 57215.2.4　使用变量的方法 57215.2.5　如何解析变量 57315.3　定义内部变量  57615.4　外部变量与脚本引擎 57715.4.1　相关数据结构 57815.4.2　编译“set”脚本  58115.4.3　脚本执行流程 58615.5　小结  589第16章　slab共享内存  59016.1　操作slab共享内存的方法  59016.2　使用slab共享内存池的例子  59216.2.1　共享内存中的数据结构 59316.2.2　操作共享内存中的红黑树与链表 59516.2.3　解析配置文件 60016.2.4　定义模块  60316.3　slab内存管理的实现原理  60516.3.1　内存结构布局 60716.3.2　分配内存流程 61316.3.3　释放内存流程 61716.3.4　如何使用位操作 61916.3.5　slab内存池间的管理  62416.4　小结  624	 
